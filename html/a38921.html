<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: DG Flux Implementation Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a38921.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DG Flux Implementation Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we demonstrate how to compute an integral on a boundary face</p>
<p>The definitions section is composed by a first part, which is similar to the one in the previous examples </p><div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keyword">using</span> <a class="code" href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">matrix_storage_info_t</a>=storage_info&lt; __COUNTER__, layout_tt&lt;6&gt;&gt;;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keyword">using</span> matrix_type=storage_t&lt; matrix_storage_info_t &gt;;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">using</span> fe=reference_element&lt;1, Lagrange, Hexa&gt;;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keyword">using</span> geo_map=reference_element&lt;1, Lagrange, Hexa&gt;;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keyword">using</span> cub=cubature&lt;fe::order()+1, fe::shape()&gt;;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keyword">using</span> geo_t = intrepid::geometry&lt;geo_map, cub&gt;;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    geo_t geo;</div><div class="ttc" id="a36805_html_a0f78c5a11c5fa18481f0302399e28368"><div class="ttname"><a href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">legendre::matrix_storage_info_t</a></div><div class="ttdeci">storage_info&lt; __COUNTER__, layout_tt&lt; 5 &gt; &gt; matrix_storage_info_t</div><div class="ttdoc">[discretization] </div><div class="ttdef"><b>Definition:</b> definitions.hpp:81</div></div>
</div><!-- fragment --><p>Notice however that we did not define the discretization an geometric map, since in this example we will be integrating only on the boundary. A second part is necessary to define the cubature on the boundary faces, and the discretization: </p><div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keyword">using</span> bd_cub_geo_t = intrepid::boundary_cub&lt;fe, cub::cubDegree&gt;;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keyword">using</span> bd_cub_discr_t = intrepid::boundary_cub&lt;geo_map, cub::cubDegree&gt;;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keyword">using</span> bd_discr_t = intrepid::boundary_discr&lt;bd_cub_discr_t, 1&gt;;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keyword">using</span> bd_geo_t = intrepid::boundary_discr&lt;bd_cub_geo_t, 1&gt;;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    bd_cub_geo_t bd_cub_geo_;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    bd_cub_discr_t bd_cub_discr_;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    bd_discr_t bd_discr_(bd_cub_discr_, 1);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    bd_geo_t bd_geo_(bd_cub_geo_, 1);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    bd_geo_.compute(Intrepid::OPERATOR_GRAD);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    bd_discr_.compute(Intrepid::OPERATOR_VALUE);</div></div><!-- fragment --><p> We compute the gradient on the faces of the reference finite element, evaluated in the quadrature points on the boundary NOTE the</p><div class="fragment"><div class="line">bd_discr_ </div></div><!-- fragment --><p> instantiation is given an ordinal (1 in this case). This ordinal identify a face in the exahedron, and can be substituted by a list of ordinals</p><div class="fragment"><div class="line">bd_discr_(bd_cub_,0,1,2,3,4,5) </div></div><!-- fragment --><p> if we consider all faces. So in this case we want to compute the boundary integral on face number 1 of each element. The face ordinals are assigned with the following convention: </p><div class="fragment"><div class="line">index  normals               .____.</div><div class="line">0      (0,-1,0)             /  0 /|</div><div class="line">1      (1,0,0)             .____. |5</div><div class="line">2      (0,1,0)             |    |1.          z</div><div class="line">3      (-1,0,0)           3|  4 |/       x__/</div><div class="line">4      (0,0,-1)            .____.           |</div><div class="line">5      (0,0,1)               2              y</div></div><!-- fragment --><p>We define for this case only the assembly_base and a bd_assembly, since we do not need the assembler for the volumetric part </p><div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keyword">using</span> as_base=assembly_base&lt;geo_t&gt;;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keyword">using</span> as=bd_assembly&lt;bd_geo_t&gt;;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    as_base assembler_base(d1,d2,d3);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    as assembler(bd_geo_,d1,d2,d3);</div></div><!-- fragment --><p>We instantiate the matrix which will contain the mass matrix of the right-boundary of each element </p><div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">matrix_storage_info_t</a> meta_(d1,d2,d3,fe::basis_cardinality(),fe::basis_cardinality(), 1<span class="comment">/*faces*/</span>);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    matrix_type mass_(meta_, 0., <span class="stringliteral">&quot;mass&quot;</span>);</div><div class="ttc" id="a36805_html_a0f78c5a11c5fa18481f0302399e28368"><div class="ttname"><a href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">legendre::matrix_storage_info_t</a></div><div class="ttdeci">storage_info&lt; __COUNTER__, layout_tt&lt; 5 &gt; &gt; matrix_storage_info_t</div><div class="ttdoc">[discretization] </div><div class="ttdef"><b>Definition:</b> definitions.hpp:81</div></div>
</div><!-- fragment --><p> Notice that this matrix is represented with a 6D array, three space dimensions identifying the element, two dimensions for specifying the degrees of freedom (row/column of the local matrix), and one extra dimension identifying the face (useless in this case since we only consider one face).</p>
<p>We define in a similar way the vectors used in the computation </p><div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keyword">using</span> vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keyword">using</span> vector_type=storage_t&lt; vector_storage_info_t &gt;;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    vector_storage_info_t vec_meta_(d1,d2,d3,fe::basis_cardinality(), 1<span class="comment">/*faces*/</span>);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    vector_type u_(vec_meta_, 2., <span class="stringliteral">&quot;u&quot;</span>);<span class="comment">//initial solution</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    vector_type flux_(vec_meta_, 0., <span class="stringliteral">&quot;flux&quot;</span>);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    vector_type integrated_flux_(vec_meta_, 0., <span class="stringliteral">&quot;integrated flux&quot;</span>);</div></div><!-- fragment --><p> Then as usual we define a placeholder for each argument we want to pass to the computation </p><div class="fragment"></div><!-- fragment --><p>the aggregator </p><div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="comment">// appending the placeholders to the list of placeholders already in place</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keyword">auto</span> domain=gt::aggregator_type&lt;arg_list&gt;(</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        (p_bd_jac()=assembler.bd_jac())</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        , (p_normals()=assembler.normals())</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        , (p_bd_measure()=assembler.bd_measure())</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        , (p_bd_weights()=assembler.bd_backend().bd_cub_weights())</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        , (p_ref_normals()=assembler.ref_normals())</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        , (p_bd_dphi()=assembler.bd_backend().grad())</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        , (p_grid_points()=assembler_base.grid())</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        , (p_mass()=mass_)</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        , (p_bd_discr_phi()=bd_discr_.val())</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        , (p_u()=u_)</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        , (p_flux()=flux_)</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        , (p_integrated_flux()=integrated_flux_)</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        );</div></div><!-- fragment --><p>and the computation </p><div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keyword">auto</span> computation=gt::make_computation&lt; BACKEND &gt;(</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        domain, coords,</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        make_multistage</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        (</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            execute&lt;forward&gt;()</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="comment">// evaluate the cell Jacobian matrix on the boundary (given the basis functions derivatives in those points)</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            , gt::make_stage&lt;functors::update_bd_jac&lt;bd_discr_t , enumtype::Hexa&gt; &gt;(p_grid_points(), p_bd_dphi(), p_bd_jac())</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            <span class="comment">// compute the normals on the quad points from the jacobian above, transporting the normals from the reference configuration, unnecessary. (can be computed also as the cross product of the first 2 columns of J)</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            , gt::make_stage&lt;functors::compute_face_normals&lt;bd_discr_t&gt; &gt;(p_bd_jac(), p_ref_normals(), p_normals())</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="comment">// surface integral:</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="comment">// compute the measure for the surface integral</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="comment">//            |  / d(phi_x)/du   d(phi_x)/dv  1 \  |</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="comment">//   det(J) = | |  d(phi_y)/du   d(phi_y)/dv  1  | |</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="comment">//            |  \ d(phi_z)/du   d(phi_z)/dv  1 /  |</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            , gt::make_stage&lt;functors::measure&lt;bd_discr_t, 1&gt; &gt;(p_bd_jac(), p_bd_measure())</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            <span class="comment">// evaluate the mass matrix</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            , gt::make_stage&lt;functors::bd_mass&lt;fe, bd_cub_discr_t::bd_cub&gt; &gt;(p_bd_measure(), p_bd_weights(), p_bd_discr_phi(), p_bd_discr_phi(), p_mass()) <span class="comment">//mass</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="comment">// compute the flux, this line defines the type of approximation we choose for DG</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            <span class="comment">// (e.g. upwind, centered, Lax-Wendroff and so on)</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            <span class="comment">// NOTE: if not linear we cannot implement it as a matrix</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            , gt::make_stage&lt;functors::bassi_rebay&lt;bd_discr_t&gt; &gt;(p_u(), p_u(), p_flux())</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="comment">// integrate the flux: mass*flux</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            , gt::make_stage&lt; functors::matvec_BdxBdxBd &gt;( p_flux(), p_mass(), p_integrated_flux() )</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            ));</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    computation-&gt;ready();</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    computation-&gt;steady();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    computation-&gt;run();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    computation-&gt;finalize();</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="comment">// spy not working yet for non-3D matrices \TODO fix</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="comment">// spy(mass_, &quot;bd_mass&quot;);</span></div></div><!-- fragment --><p> As in the previous examples we distingush between the basis functions used for the geometry interpolation and the finite elements discretization. If we want different order or basis functions for the 2, than we have to distinguish the 2, i.e. when computing the Jacobian matrices use the geometric map basis functions, and when discretizing use the discretization ones.</p>
<p>The different steps of the computation are:</p><ul>
<li>compute the jacobian matrix on the boundary</li>
<li>compute the face normals</li>
<li>compute the boundary measure (i.e. the norm of the cross product of the tangent derivatives <img class="formulaInl" alt="$ dt_1\times dt_2$" src="form_3.png"/>)</li>
<li>evaluate the mass matrix</li>
<li>evaluate a flux across the boundary</li>
<li>integrate the flux on the face (i.e. perform a multiplication with the boundary mass matrix)</li>
</ul>
<p>We show below the patterns of the assembled boundary mass matrix, obtained using the gdl::spy function</p>
<div class="image">
<img src="bd_mass_order1.png" alt="bd_mass_order1.png"/>
</div>
 <div class="image">
<img src="2x2_order1.png" alt="2x2_order1.png"/>
</div>
 <div class="image">
<img src="bd_mass_order2.png" alt="bd_mass_order2.png"/>
</div>
 <div class="image">
<img src="2x2_mass_order2.png" alt="2x2_mass_order2.png"/>
</div>
 <div class="image">
<img src="bd_mass_order3.png" alt="bd_mass_order3.png"/>
</div>
 <div class="image">
<img src="2x2_mass_order3.png" alt="2x2_mass_order3.png"/>
</div>
<h1>Full Code </h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//this MUST be included before any boost include</span></div><div class="line"><span class="preprocessor">#define FUSION_MAX_VECTOR_SIZE 40</span></div><div class="line"><span class="preprocessor">#define FUSION_MAX_MAP_SIZE FUSION_MAX_VECTOR_SIZE</span></div><div class="line"><span class="preprocessor">#define BOOST_MPL_LIMIT_VECTOR_SIZE FUSION_MAX_VECTOR_SIZE</span></div><div class="line"><span class="preprocessor">#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#define PEDANTIC_DISABLED</span></div><div class="line"><span class="preprocessor">#define HAVE_INTREPID_DEBUG</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/bd_assembly.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="a36503.html">test_dg_flux.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../functors/dg_fluxes.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../functors/matvec.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tools/spy.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a36497.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv){</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="a36804.html">gdl</a>;</div><div class="line">    <span class="keyword">using namespace </span>enumtype;</div><div class="line"></div><div class="line">    uint_t d1;</div><div class="line">    uint_t d2;</div><div class="line">    uint_t d3;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(argc==1){</div><div class="line">        d1 = 5;</div><div class="line">        d2 = 5;</div><div class="line">        d3 = 5;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span>{</div><div class="line">        <span class="keywordflow">if</span>(argc!=4) {</div><div class="line">            printf(<span class="stringliteral">&quot;usage: \n &gt;&gt; stiffness &lt;d1&gt; &lt;d2&gt; &lt;d3&gt;\n&quot;</span>);</div><div class="line">            exit(-666);</div><div class="line">        }</div><div class="line">        <span class="comment">//dimensions of the problem (in number of elements per dimension)</span></div><div class="line">        d1= atoi(argv[1]);</div><div class="line">        d2= atoi(argv[2]);</div><div class="line">        d3= atoi(argv[3]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//defining the assembler, based on the Intrepid definitions for the numerics</span></div><div class="line"><span class="comment"></span>    <span class="keyword">using</span> <a class="code" href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">matrix_storage_info_t</a>=storage_info&lt; __COUNTER__, layout_tt&lt;6&gt;&gt;;</div><div class="line">    <span class="keyword">using</span> matrix_type=storage_t&lt; matrix_storage_info_t &gt;;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> fe=<a class="code" href="a37825.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_map=<a class="code" href="a37825.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> cub=<a class="code" href="a37933.html">cubature&lt;fe::order()+1, fe::shape()&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_t = <a class="code" href="a38021.html">intrepid::geometry&lt;geo_map, cub&gt;</a>;</div><div class="line">    geo_t geo;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> bd_cub_geo_t = <a class="code" href="a38025.html">intrepid::boundary_cub&lt;fe, cub::cubDegree&gt;</a>;</div><div class="line">    <span class="keyword">using</span> bd_cub_discr_t = <a class="code" href="a38025.html">intrepid::boundary_cub&lt;geo_map, cub::cubDegree&gt;</a>;</div><div class="line">    <span class="keyword">using</span> bd_discr_t = <a class="code" href="a38029.html">intrepid::boundary_discr&lt;bd_cub_discr_t, 1&gt;</a>;</div><div class="line">    <span class="keyword">using</span> bd_geo_t = <a class="code" href="a38029.html">intrepid::boundary_discr&lt;bd_cub_geo_t, 1&gt;</a>;</div><div class="line">    bd_cub_geo_t bd_cub_geo_;</div><div class="line">    bd_cub_discr_t bd_cub_discr_;</div><div class="line">    bd_discr_t bd_discr_(bd_cub_discr_, 1);</div><div class="line">    bd_geo_t bd_geo_(bd_cub_geo_, 1);</div><div class="line"></div><div class="line">    bd_geo_.compute(Intrepid::OPERATOR_GRAD);</div><div class="line">    bd_discr_.compute(Intrepid::OPERATOR_VALUE);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> as_base=<a class="code" href="a37789.html">assembly_base&lt;geo_t&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as=<a class="code" href="a37829.html">bd_assembly&lt;bd_geo_t&gt;</a>;</div><div class="line">    as_base assembler_base(d1,d2,d3);</div><div class="line">    as assembler(bd_geo_,d1,d2,d3);</div><div class="line"></div><div class="line">    <span class="comment">//constructing a structured cartesian grid</span></div><div class="line">    <span class="keywordflow">for</span> (uint_t i=0; i&lt;d1; i++)</div><div class="line">        <span class="keywordflow">for</span> (uint_t j=0; j&lt;d2; j++)</div><div class="line">            <span class="keywordflow">for</span> (uint_t k=0; k&lt;d3; k++)</div><div class="line">                <span class="keywordflow">for</span> (uint_t point=0; point&lt;fe::basis_cardinality(); point++)</div><div class="line">                {</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  0)= (i + (1+geo.grid()(point, 0, 0))/2.)/d1;</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  1)= (j + (1+geo.grid()(point, 1, 0))/2.)/d2;</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  2)= (k + (1+geo.grid()(point, 2, 0))/2.)/d3;</div><div class="line">                }</div><div class="line"></div><div class="line">    <span class="comment">//defining the mass matrix: d1xd2xd3 elements</span></div><div class="line"><span class="comment"></span>    <a class="code" href="a36805.html#a0f78c5a11c5fa18481f0302399e28368">matrix_storage_info_t</a> meta_(d1,d2,d3,fe::basis_cardinality(),fe::basis_cardinality(), 1<span class="comment">/*faces*/</span>);</div><div class="line">    matrix_type mass_(meta_, 0., <span class="stringliteral">&quot;mass&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> vector_type=storage_t&lt; vector_storage_info_t &gt;;</div><div class="line">    vector_storage_info_t vec_meta_(d1,d2,d3,fe::basis_cardinality(), 1<span class="comment">/*faces*/</span>);</div><div class="line">    vector_type u_(vec_meta_, 2., <span class="stringliteral">&quot;u&quot;</span>);<span class="comment">//initial solution</span></div><div class="line">    vector_type flux_(vec_meta_, 0., <span class="stringliteral">&quot;flux&quot;</span>);</div><div class="line">    vector_type integrated_flux_(vec_meta_, 0., <span class="stringliteral">&quot;integrated flux&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;0, typename as::jacobian_type &gt;       p_bd_jac;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;1, typename as::face_normals_type &gt;                   p_normals;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;2, typename as::storage_type &gt;        p_bd_measure;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;3, typename as::boundary_t::weights_storage_t&gt; p_bd_weights;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;4, typename as::boundary_t::tangent_storage_t&gt; p_ref_normals;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;5, typename as::boundary_t::grad_storage_t&gt; p_bd_dphi;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;6, typename as_base::grid_type &gt;       p_grid_points;</div><div class="line"></div><div class="line">    <span class="comment">// defining the placeholder for the mass</span></div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;7, matrix_type&gt; p_mass;</div><div class="line">    <span class="comment">// defining the placeholder for the local gradient of the element boundary face</span></div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;8, bd_discr_t::basis_function_storage_t&gt; p_bd_discr_phi;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;9, vector_type&gt; p_u;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;10, vector_type&gt; p_flux;</div><div class="line">    <span class="keyword">typedef</span> gt::arg&lt;11, vector_type&gt; p_integrated_flux;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_bd_jac, p_normals, p_bd_measure, p_bd_weights, p_ref_normals, p_bd_dphi, p_grid_points, p_mass, p_bd_discr_phi, p_u, p_flux, p_integrated_flux&gt; arg_list;</div><div class="line"></div><div class="line">    <span class="comment">// appending the placeholders to the list of placeholders already in place</span></div><div class="line">    <span class="keyword">auto</span> domain=gt::aggregator_type&lt;arg_list&gt;(</div><div class="line">        (p_bd_jac()=assembler.bd_jac())</div><div class="line">        , (p_normals()=assembler.normals())</div><div class="line">        , (p_bd_measure()=assembler.bd_measure())</div><div class="line">        , (p_bd_weights()=assembler.bd_backend().bd_cub_weights())</div><div class="line">        , (p_ref_normals()=assembler.ref_normals())</div><div class="line">        , (p_bd_dphi()=assembler.bd_backend().grad())</div><div class="line">        , (p_grid_points()=assembler_base.grid())</div><div class="line">        , (p_mass()=mass_)</div><div class="line">        , (p_bd_discr_phi()=bd_discr_.val())</div><div class="line">        , (p_u()=u_)</div><div class="line">        , (p_flux()=flux_)</div><div class="line">        , (p_integrated_flux()=integrated_flux_)</div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="comment">// auto coords=gt::grid&lt;axis&gt;({1, 0, 1, (uint_t)d1-1, (uint_t)d1},</span></div><div class="line">    <span class="comment">//     {1, 0, 1, (uint_t)d2-1, (uint_t)d2});</span></div><div class="line">    <span class="keyword">auto</span> coords=gt::grid&lt;axis&gt;({0, 0, 0, (uint_t)d1-1, (uint_t)d1},</div><div class="line">        {0, 0, 0, (uint_t)d2-1, (uint_t)d2});</div><div class="line">    coords.value_list[0] = 0;</div><div class="line">    coords.value_list[1] = d3-1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> computation=gt::make_computation&lt; BACKEND &gt;(</div><div class="line">        domain, coords,</div><div class="line">        make_multistage</div><div class="line">        (</div><div class="line">            execute&lt;forward&gt;()</div><div class="line">            <span class="comment">// evaluate the cell Jacobian matrix on the boundary (given the basis functions derivatives in those points)</span></div><div class="line">            , gt::make_stage&lt;functors::update_bd_jac&lt;bd_discr_t , enumtype::Hexa&gt; &gt;(p_grid_points(), p_bd_dphi(), p_bd_jac())</div><div class="line">            <span class="comment">// compute the normals on the quad points from the jacobian above, transporting the normals from the reference configuration, unnecessary. (can be computed also as the cross product of the first 2 columns of J)</span></div><div class="line">            , gt::make_stage&lt;functors::compute_face_normals&lt;bd_discr_t&gt; &gt;(p_bd_jac(), p_ref_normals(), p_normals())</div><div class="line">            <span class="comment">// surface integral:</span></div><div class="line">            <span class="comment">// compute the measure for the surface integral</span></div><div class="line">            <span class="comment">//            |  / d(phi_x)/du   d(phi_x)/dv  1 \  |</span></div><div class="line">            <span class="comment">//   det(J) = | |  d(phi_y)/du   d(phi_y)/dv  1  | |</span></div><div class="line">            <span class="comment">//            |  \ d(phi_z)/du   d(phi_z)/dv  1 /  |</span></div><div class="line">            , gt::make_stage&lt;functors::measure&lt;bd_discr_t, 1&gt; &gt;(p_bd_jac(), p_bd_measure())</div><div class="line">            <span class="comment">// evaluate the mass matrix</span></div><div class="line">            , gt::make_stage&lt;functors::bd_mass&lt;fe, bd_cub_discr_t::bd_cub&gt; &gt;(p_bd_measure(), p_bd_weights(), p_bd_discr_phi(), p_bd_discr_phi(), p_mass()) <span class="comment">//mass</span></div><div class="line">            <span class="comment">// compute the flux, this line defines the type of approximation we choose for DG</span></div><div class="line">            <span class="comment">// (e.g. upwind, centered, Lax-Wendroff and so on)</span></div><div class="line">            <span class="comment">// NOTE: if not linear we cannot implement it as a matrix</span></div><div class="line">            , gt::make_stage&lt;functors::bassi_rebay&lt;bd_discr_t&gt; &gt;(p_u(), p_u(), p_flux())</div><div class="line">            <span class="comment">// integrate the flux: mass*flux</span></div><div class="line">            , gt::make_stage&lt; functors::matvec_BdxBdxBd &gt;( p_flux(), p_mass(), p_integrated_flux() )</div><div class="line">            ));</div><div class="line"></div><div class="line">    computation-&gt;ready();</div><div class="line">    computation-&gt;steady();</div><div class="line">    computation-&gt;run();</div><div class="line">    computation-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="comment">// spy not working yet for non-3D matrices \TODO fix</span></div><div class="line">    <span class="comment">// spy(mass_, &quot;bd_mass&quot;);</span></div><div class="line"><span class="comment"></span>    <span class="comment">//check that the boundary mass is correct</span></div><div class="line">    <span class="comment">// gt::intrepid::template test&lt;geo_t&gt;(assembler_base, assembler, bd_discr_, mass_);</span></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 14 2017 12:01:27 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
