<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Poisson problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a38837.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Poisson problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we compute the solution of a 3D Poisson problem with generic (not homogeneous) Dirichlet boundary conditions and source term definition in a cubic domain.</p>
<p>The first operations performed in this example, already discussed in previous cases, are the definition of some parameters related to linear solver usage </p><div class="fragment"><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> stability_thr(-1.0);</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> error_thr(1.e-20);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keywordtype">double</span> stability;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <a class="code" href="a38228.html">uint_t</a> max_iter(10000);</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> of domain size </p><div class="fragment"><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> d1=4;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> d2=4;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> d3=4;</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> and of some FEM related elements </p><div class="fragment"><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keyword">using</span> fe=reference_element&lt;1, Lagrange, Hexa&gt;;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="keyword">using</span> geo_map=reference_element&lt;1, Lagrange, Hexa&gt;;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keyword">using</span> cub=cubature&lt;2, fe::shape()&gt;;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keyword">using</span> geo_t = intrepid::geometry&lt;geo_map, cub&gt;;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="keyword">using</span> discr_t = intrepid::discretization&lt;fe, cub&gt;;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keyword">using</span> as=assembly&lt;geo_t&gt;;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keyword">using</span> as_base=assembly_base&lt;geo_t&gt;;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> dof_per_dim{2};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> dof_per_el{dof_per_dim*dof_per_dim*dof_per_dim};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    constexpr gridtools::uint_t n_dof{((dof_per_dim-1)*d1+1)*((dof_per_dim-1)*d2+1)*((dof_per_dim-1)*d3+1)};</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    constexpr gridtools::uint_t n_dofx{(dof_per_dim-1)*d1+1};</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    constexpr gridtools::uint_t n_dofy{(dof_per_dim-1)*d2+1};</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    constexpr gridtools::uint_t n_dofz{(dof_per_dim-1)*d3+1};</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> We don't discuss here the details of the above definitions since they have been already used in previous examples. Also the declaration of storages is identical to the one described in the previous example, as it can be seen in the source code snippets that follow </p><div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    <span class="comment">// Stiffness matrix</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keyword">using</span> stiffness_matrix_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="keyword">using</span> stiffness_matrix_type = gridtools::storage&lt;assemble_storage&lt; stiffness_matrix_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keyword">using</span> source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    <span class="keyword">using</span> source_vector_type = gridtools::storage&lt;assemble_storage&lt; source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keyword">using</span> interpolated_source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="keyword">using</span> interpolated_source_vector_type = gridtools::storage&lt;assemble_storage&lt; interpolated_source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="comment">// Source evaluation grid</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="keyword">using</span> source_evaluation_grid_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="keyword">using</span> source_evaluation_grid_type = storage_t&lt;source_evaluation_grid_storage_info_t&gt;;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="comment">// Solution vector</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keyword">using</span> solution_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="keyword">using</span> solution_vector_type = gridtools::storage&lt;assemble_storage&lt; solution_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;</div></div><!-- fragment --><p> and</p>
<div class="fragment"><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> ass_d1{d1+1};</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> ass_d2{d2+1};</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> ass_d3{d3+1};</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    <span class="comment">// Computational domain: this is the domain used for linear system solution calculation namely the physical domain plus a 1 element halo (along all domain boundary faces)</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> comp_d1{d1+2};</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> comp_d2{d2+2};</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    constexpr <a class="code" href="a38228.html">uint_t</a> comp_d3{d3+2};</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="comment">// Stiffness matrix</span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    stiffness_matrix_storage_info_t stiffness_(comp_d1,comp_d2,comp_d3,dof_per_el,dof_per_el);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    stiffness_matrix_type stiffness(stiffness_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;stiffness&quot;</span>);<span class="comment">// This is the unassembled problem matrix</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    source_vector_storage_info_t source_values_(comp_d1,comp_d2,comp_d3,cub::numCubPoints());</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    source_vector_type source_values(source_values_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;source_values&quot;</span>);<span class="comment">// These are the source values computed at cubature point of each mesh element </span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    interpolated_source_vector_storage_info_t interpolated_source_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    interpolated_source_vector_type interpolated_source(interpolated_source_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;interpolated source&quot;</span>);<span class="comment">// This is the unassembled right hand side vector</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="comment">// Source evaluation grid</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    source_evaluation_grid_storage_info_t source_evaluation_grid_(ass_d1,ass_d2,ass_d3,cub::numCubPoints(),3);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    source_evaluation_grid_type source_evaluation_grid(source_evaluation_grid_,0,<span class="stringliteral">&quot;source_evaluation_grid&quot;</span>);<span class="comment">// This is the grid of cubature points on which the source is evaluated</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="comment">// Solution vector</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    solution_vector_storage_info_t sol_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    solution_vector_type sol(sol_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;sol&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> the only difference being the presence of the additional storages for source term evaluation on cubature points (we will provide details about this in what follows). In the subsequent step we define what we call the computational domain <code>ass_with_halo_coords</code>, corresponding to the physical domain whose size is defined at the beginning of the example plus a one element halo in the three dimensions (on the domain origin sides). As already discussed in the previous example, this is related to some implementation details of the linear solver. </p><div class="fragment"><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keyword">auto</span> ass_with_halo_coords=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    ass_with_halo_coords.value_list[0] = 1;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    ass_with_halo_coords.value_list[1] = ass_d3-1;</div></div><!-- fragment --><p> Then we instantiate the discretization and quadrature variables and, like in the stiffness calculation example, we perform the calculation of basis function values and gradients on the cubature points and of the values of the geometric map as well. In this same code block we also define the assembly objects. </p><div class="fragment"><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    geo_t geo_;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    discr_t fe_;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    geo_.<a class="code" href="a37922.html#a79fd100ccc3f922a503fbbfd16c83891">compute</a>(Intrepid::OPERATOR_GRAD);<span class="comment">//redundants</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="comment">//    geo_.compute(Intrepid::OPERATOR_VALUE);</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    fe_.compute(Intrepid::OPERATOR_GRAD);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    fe_.compute(Intrepid::OPERATOR_VALUE);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keyword">using</span> as=assembly&lt;geo_t&gt;;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keyword">using</span> as_base=assembly_base&lt;geo_t&gt;;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    as assembler( geo_, ass_d1, ass_d2, ass_d3);</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    as_base assembler_base(ass_d1, ass_d2, ass_d3);</div><div class="ttc" id="a37922_html_a79fd100ccc3f922a503fbbfd16c83891"><div class="ttname"><a href="a37922.html#a79fd100ccc3f922a503fbbfd16c83891">gdl::intrepid::discretization::compute</a></div><div class="ttdeci">void compute(Intrepid::EOperator const &amp;operator_)</div><div class="ttdoc">computing the operator passed as input applied to all the basis functions </div><div class="ttdef"><b>Definition:</b> intrepid.hpp:194</div></div>
</div><!-- fragment --><p> Given the assembly variables we define the structured grid representing our mesh of hexahedrons </p><div class="fragment"><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    <span class="comment">//constructing a structured cartesian grid</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="a38228.html">uint_t</a> i=0; i&lt;ass_d1; i++)</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="a38228.html">uint_t</a> j=0; j&lt;ass_d2; j++)</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="a38228.html">uint_t</a> k=0; k&lt;ass_d3; k++){</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="a38228.html">uint_t</a> point=0; point&lt;geo_map::basis_cardinality(); point++)</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;                {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                    <span class="comment">// TODO: here we use the reordered_grid method in order to have the same dof ordering of deal.II</span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                    assembler_base.grid()( i,  j,  k,  point,  0)= (2*i + geo_.reordered_grid()(point, 0, 0) - 1.);</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                    assembler_base.grid()( i,  j,  k,  point,  1)= (2*j + geo_.reordered_grid()(point, 1, 0) - 1.);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                    assembler_base.grid()( i,  j,  k,  point,  2)= (2*k + geo_.reordered_grid()(point, 2, 0) - 1.);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                }</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;            }</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> At this point of the example we focus on the calculation of the source term of the FEM problem. This task is performed in 3 steps:</p><ul>
<li>generation of the grid of cubature points on the mesh elements, starting from the cubature points of the reference element</li>
<li>evaluation of the source function on the generated cubature point grid</li>
<li>calculation of the integrals between source function and basis functions, for all mesh elements</li>
</ul>
<p>Let's start with the first two steps: according to FEM theory, the source term is introduced in the linear system of the discretized problem following the same strategy of mass matrix calculation, namely through the interpolation of the source term function over the basis function set for all mesh elements. This corresponds to the calculation of the integral between the source term function and the discretization basis functions over all mesh elements taking into account the geometrical trasformation between the reference element and the real mesh elements. From a computational point of view this operation requires the evaluation of the source term function in corrispondence of the cubature points after the transformation of their coordinates with the adopted geometrical map. The first computational task performed in this phase is therefore the generation of the real cubature point grid, for the specific mesh considered for this example. This operation is performed by the <code>cubature_point_grid_generation</code> functor implemented as follows: </p><div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Geometry, enumtype::Shape S=Geometry::parent_shape &gt;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keyword">struct </span>cubature_point_grid_generation {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;          </div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="keyword">using</span> cub=<span class="keyword">typename</span> Geometry::cub;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 3&gt; <span class="keyword">const</span> phi;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keyword">typedef</span> gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; transf_grid_points;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, phi, transf_grid_points&gt; arg_list;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                gt::dimension&lt;1&gt; dof_coord_phi;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                gt::dimension&lt;2&gt; cub_dim_phi;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                gt::dimension&lt;4&gt; point_dim;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                gt::dimension&lt;5&gt; coord_dim;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                </div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                </div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="preprocessor">#ifndef __CUDACC__</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                assert(num_cub_points==cub::numCubPoints());</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <span class="comment">//TODO dimensions should be generic</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                <span class="keywordflow">for</span>(short_t coord=0; coord&lt; shape_property&lt;Geometry::parent_shape&gt;::dimension; ++coord)</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                    <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                    {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                        eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) = 0.;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                        <span class="keywordflow">for</span> (int_t dof=0; dof &lt; basis_cardinality ; ++dof)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                        {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                          eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) += </div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                            eval(grid_points(point_dim+dof,coord_dim+coord)*!phi(dof,cub_point,0));</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                        }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                    }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                }                </div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            }</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        };</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> As it can bee seen from the above functor implementation, here we are just applying a geometrical coordinates transformation from the reference element to a real one for all the cubature points. The execution of this functor is performed as first step by the <code>source_eval</code> computation defined as follows </p><div class="fragment"><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keyword">auto</span> source_eval=gt::make_computation&lt;BACKEND&gt;(source_eval_domain,</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                                                   ass_with_halo_coords,</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                                                   make_multistage(</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                                                       execute&lt;forward&gt;(),</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                                                       gt::make_stage&lt;<a class="code" href="a37326.html">gdl::functors::cubature_point_grid_generation&lt;geo_t&gt;</a> &gt;( </div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                                                           p_grid_points_src(),</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                                                           p_phi_src(),</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                                                           p_source_evaluation_grid_src()),</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                                                       gt::make_stage&lt;<a class="code" href="a37330.html">gdl::functors::function_evaluation&lt;gdl::functors::quartic_source&gt;</a> &gt;(</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                                                           p_source_evaluation_grid_src(),</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                                                           p_source_values_src())</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                                                                   ));</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    source_eval-&gt;ready();</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    source_eval-&gt;steady();</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    source_eval-&gt;run();</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    source_eval-&gt;finalize();</div><div class="ttc" id="a37330_html"><div class="ttname"><a href="a37330.html">gdl::functors::function_evaluation</a></div><div class="ttdef"><b>Definition:</b> poisson.cpp:113</div></div>
<div class="ttc" id="a37326_html"><div class="ttname"><a href="a37326.html">gdl::functors::cubature_point_grid_generation</a></div><div class="ttdef"><b>Definition:</b> poisson.cpp:65</div></div>
</div><!-- fragment --><p>and covers the full physical domain mesh, according to the definition of the grid <code>ass_with_halo_coords</code> provided to the <code>source_eval</code> computation. The computed cubature point grid is stored in the <code>source_evaluation_grid</code> storage. Now that we have the grid of cubature points we can evaluate the source function in correspondence to their coordinates, as is performed during the second stage of <code>source_eval</code> making use of the <code>function_evaluation</code> functor defined as follows </p><div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionDefinition&gt;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keyword">struct </span>function_evaluation {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          </div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; function_values;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, function_values&gt; arg_list;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                gt::dimension&lt;4&gt; point_dim;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                gt::dimension&lt;5&gt; coord_dim;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                </div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;3&gt;(grid_points());</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                </div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+cub_point,coord_dim+0));</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+cub_point,coord_dim+1));</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+cub_point,coord_dim+2));</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                  eval(function_values(point_dim+cub_point)) = FunctionDefinition::compute(x,y,z);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                }                </div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        };</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> This functor is a generic interface for source function evaluation which takes a functor implementing the mathematical definition of the source function itself as template parameter: according to its implementation, all the functors representing a source function definition must implement the <code>compute</code> method returning the source value for the provided position in domain. According to the above code snippet, the output of this second stage of <code>source_eval</code> is represented by the values of the source function for all the cubature points of the mesh elements and is stored in the <code>source_values</code> storage. The source term definition is implementd in this example in the <code>quartic_source</code> functor as </p><div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keyword">struct </span>quartic_source {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                <span class="keywordflow">return</span> 4.*(i_x*i_x*i_x*i_x + i_y*i_y*i_y*i_y + i_z*i_z*i_z*i_z);</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            }</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        };</div></div><!-- fragment --><p>namely as a quartic polynomial of the evaluation point coordinates.</p>
<p>The third and last step of source term computation is represented by the calculation of the numerical integral between the the source function and the basis functions, for all mesh elements, and is performed by the <code>source_interp</code> computation through 3 stages: the first two are the jacobian and jacobian determinant calculation stencils respectively, already described in previous examples like the mass matrix calculation case, while the last one performs the geometrical mapping between reference and real mesh elements making use of the <code>not_normalized_transform</code> functor implemented as follows: </p><div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keyword">struct </span>not_normalized_transform {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keyword">using</span> jac_det=gt::accessor&lt;0, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            <span class="keyword">using</span> weights   =gt::accessor&lt;1, enumtype::inout, gt::extent&lt;&gt; , 3&gt; ;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keyword">using</span> phi   =gt::accessor&lt;2, enumtype::in   , gt::extent&lt;&gt; , 3&gt; <span class="keyword">const</span>;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            <span class="keyword">using</span> in   =gt::accessor&lt;3, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keyword">using</span> out   =gt::accessor&lt;4, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; jac_det, weights, phi, in, out &gt; ;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                gt::dimension&lt;4&gt; qp;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                gt::dimension&lt;5&gt; dimx;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                </div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <span class="keywordflow">for</span>(short_t P_i=0; P_i&lt;basis_cardinality; ++P_i) <span class="comment">// current dof</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                    eval(out((<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)P_i))=0.;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                    <span class="keywordflow">for</span>(short_t q=0; q&lt;num_cub_points; ++q){</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                      assert(eval(jac_det(qp+q)));</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                      eval(out((<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)0,(<a class="code" href="a38228.html">uint_t</a>)P_i))  +=</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                        eval(!phi(P_i,q,0)*in(qp+q)*!weights(q,0,0)*jac_det(qp+q));</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                    }</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        };</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p>This completes the calculation of the FEM linear system source term, stored in the <code>interpolated_source</code> storage.</p>
<p>At this point we proceed with stiffness matrix calculation: </p><div class="fragment"><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    <span class="comment">//[placeholders]</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;0, discr_t::grad_storage_t&gt; p_dphi;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;1, discr_t::grad_storage_t&gt; p_dpsi;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;2, as::jacobian_type&gt; p_jac;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;3, as::storage_type&gt; p_jac_det;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;4, as::jacobian_type&gt; p_jac_inv;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;5, as::weights_storage_t&gt; p_weights;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keyword">typedef</span> gridtools::arg&lt;6, stiffness_matrix_type&gt; p_stiffness;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <span class="comment">//[placeholders]</span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="comment">//[domain]</span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_dphi, p_dpsi, p_jac, p_jac_det, p_jac_inv, p_weights, p_stiffness&gt; stiffness_calculation_domain_accessors;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    gridtools::aggregator_type&lt;stiffness_calculation_domain_accessors&gt; stiffness_calculation_domain(boost::fusion::make_vector(&amp;fe_.grad(), </div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                                                                                                                               &amp;fe_.grad(), </div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                                                                                                                               &amp;assembler.jac(), </div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                                                                                                                               &amp;assembler.jac_det(), </div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                                                                                                                               &amp;assembler.jac_inv(), </div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                                                                                                                               &amp;assembler.cub_weights(), </div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;                                                                                                                               &amp;stiffness));</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    <span class="comment">//[domain]</span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    <span class="comment">//[computation]    </span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="keyword">auto</span> compute_stiffness=gt::make_computation&lt;BACKEND&gt;(</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        stiffness_calculation_domain,</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        ass_with_halo_coords,</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        make_multistage(</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            execute&lt;forward&gt;(),</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            gt::make_stage&lt;<a class="code" href="a37402.html">gdl::functors::inv&lt;geo_t&gt;</a> &gt;(p_jac(), p_jac_det(), p_jac_inv()),</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            gt::make_stage&lt;<a class="code" href="a37570.html">gdl::functors::stiffness&lt;fe, cub&gt;</a> &gt;(p_jac_det(), p_jac_inv(), p_weights(), p_dphi(), p_dpsi(), p_stiffness())<span class="comment">//stiffness</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        ));</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    compute_stiffness-&gt;ready();</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    compute_stiffness-&gt;steady();</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    compute_stiffness-&gt;run();</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    compute_stiffness-&gt;finalize();</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    <span class="comment">//[computation]</span></div><div class="ttc" id="a37402_html"><div class="ttname"><a href="a37402.html">gdl::functors::inv</a></div><div class="ttdef"><b>Definition:</b> assembly_functors.hpp:175</div></div>
<div class="ttc" id="a37570_html"><div class="ttname"><a href="a37570.html">gdl::functors::stiffness</a></div><div class="ttdef"><b>Definition:</b> stiffness.hpp:45</div></div>
</div><!-- fragment --><p> All the details about this calculation have been already discussed in a previous specific example.</p>
<p>Once that the stiffness matrix and the source vector are available, we are ready to introduce the boundary conditions. In the present case we have chosen to impose (not homogeneous) Dirichlet boundary conditions: from a mathematical point of view this operation can be performed by setting to 0 all the matrix elements of the rows corresponding to a boundary dof except for the diagonal element, whose value is instead set to 1. The source term needs to modified too and this is done by setting the boundary elements equal to the corresponding values determined by the boundary condition definition. It must be noted that the described strategy can be applied also in our case, characterized by having unassembled stiffness matrix and source vector: introducing the above modifications in the local (i.e., element by element) stiffness matrices and source vectors we look for the solution of a linear system identical to the one of the assembled case except for a multiplicative factor for the rows corresponding to the boundary dofs, the factor value being equal to the number of mesh elements sharing the dofs themselves. Since this factor, for a given row, is the same for the stiffness matrix and the source vector the problem solution does not change. The above procedure is implemented in our example by means of six computations each one corresponding to one face (or boundary) of the considered domain: top/bottom, left/right and front/rear. The operations performed by each computation are basically the same the only difference being the set of mesh elements and dofs considered, for this reason we will limit the discussion to the top boundary corresponding to the <code>apply_bc_top</code> computation: </p><div class="fragment"><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    <span class="keyword">auto</span> apply_bc_top=gt::make_computation&lt;BACKEND&gt;(</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        bc_application_domain,</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        bc_application_domain_coords_top,</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        make_multistage(</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            execute&lt;forward&gt;(),</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            gt::make_stage&lt;<a class="code" href="a37346.html">gdl::functors::apply_dirichlet_boundary_conditions_top&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        ));</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    apply_bc_top-&gt;ready();</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    apply_bc_top-&gt;steady();</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    apply_bc_top-&gt;run();</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    apply_bc_top-&gt;finalize();</div><div class="ttc" id="a37346_html"><div class="ttname"><a href="a37346.html">gdl::functors::apply_dirichlet_boundary_conditions_top</a></div><div class="ttdef"><b>Definition:</b> poisson.cpp:197</div></div>
</div><!-- fragment --><p> As it can be seen from the above code snippet, the introduction of boundary conditions for the top side of our cubic domain is performed by means of a single stencil making use of the <code>apply_dirichlet_boundary_conditions_top</code> functor implemented as follows: </p><div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_top {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                gt::dimension&lt;4&gt; point_dim;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                gt::dimension&lt;5&gt; coord_dim;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                gt::dimension&lt;4&gt; dof1;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                gt::dimension&lt;5&gt; dof2;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <a class="code" href="a38228.html">uint_t</a> <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                            eval(stiff(dof1+indexing.index(J1,0,I1),dof2+i)) = 0.;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                            eval(stiff(dof2+indexing.index(J1,0,I1),dof1+i)) = 0.;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                        }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                        eval(stiff(dof1+indexing.index(J1,0,I1),dof2+indexing.index(J1,0,I1))) = 1.;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                        </div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+0));</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+1));</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+2));</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                        eval(source(dof1+indexing.index(J1,0,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                    }</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            }</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        };</div><div class="ttc" id="a38228_html"><div class="ttname"><a href="a38228.html">uint_t</a></div></div>
</div><!-- fragment --><p> The above functor performs its work in two main steps identified by the two loops: in the first one we access all the elements of the stiffness matrix corresponding to the dofs located on the top boundary and set their value value to 0. In the second one we do a similar operation but we only access the diagonal elements of the stiffness matrix corresponding to the boundary dofs setting their value to 1. Within the same loop we access the boundary elements of the source term vector and we set their value according to the definition of the boundary condition given their positions in space. The calculation of the boundary condition value is performed through a call to the <code>compute</code> static method of the <code>BoundaryFunctionDefinition</code> type provided as template parameter to the <code>apply_dirichlet_boundary_conditions_top</code> functor. In our case the <code>BoundaryFunctionDefinition</code> parameter is represented by the <code>quadratic_boundary_value</code> functor implemented as follows: </p><div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keyword">struct </span>quadratic_boundary_value {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                <span class="keywordflow">return</span> i_x*i_x + i_y*i_y + i_z*i_z;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            }</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        };</div></div><!-- fragment --><p>As it can be seen from the above snippet, in this case the value of the boundary condition is the quadratic sum of the dof coordinates. Other mathematical definition for the Dirichlet boundary condition can be used by implementing a different <code>compute</code> method. The very same strategy is adopted for the other sides of our cubic domain the only difference being in the position of the dofs accessed by the <code>apply_dirichlet_boundary_conditions_xxx</code> functors. This difference in the dof set accessed by the functors is realized through a different implementation of index calculation for storage access and a different definition of domain coordinates. Particularly, this last difference allows to limit the work of each of the above functors to single element layers, namely the ones lying on the domain boundary faces.</p>
<p>After the introduction of boundary conditions in the stiffness matrices and source term vectors we are ready to solve the linear system: </p><div class="fragment"><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    linear_solver&lt; gdl::cg_solver&lt;dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;::solve(stiffness, interpolated_source, sol, stability_thr, error_thr, max_iter);</div></div><!-- fragment --><p>We compute the solution of the FEM linear system making use of a Conjugated Gradient method, similarly to what we did in the previous example.</p>
<p>In the remaining part of the main function we write the linear system elements on file for validation purposes.</p>
<h1>Full Code </h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">// TODO: clean include list, assembly.hpp should not be here</span></div><div class="line"></div><div class="line"><span class="comment">// TODO: remove this pedantic</span></div><div class="line"><span class="preprocessor">#define PEDANTIC_DISABLED</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assembly.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assemble_storage.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/linear_solver.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../functors/stiffness.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a36717.html">gdl</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a36723.html">gdl::enumtype</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="a36717.html">gdl</a> {</div><div class="line"></div><div class="line">    <span class="keyword">namespace </span><a class="code" href="a36725.html">functors</a> {</div><div class="line">      </div><div class="line"></div><div class="line">        <span class="comment">//[cubature_point_grid_generation]</span></div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Geometry, enumtype::Shape S=Geometry::parent_shape &gt;</div><div class="line">        <span class="keyword">struct </span>cubature_point_grid_generation {</div><div class="line">          </div><div class="line">            <span class="keyword">using</span> cub=<span class="keyword">typename</span> Geometry::cub;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 3&gt; <span class="keyword">const</span> phi;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; transf_grid_points;</div><div class="line">            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, phi, transf_grid_points&gt; arg_list;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;1&gt; dof_coord_phi;</div><div class="line">                gt::dimension&lt;2&gt; cub_dim_phi;</div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                </div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line">                uint_t <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line">                </div><div class="line"><span class="preprocessor">#ifndef __CUDACC__</span></div><div class="line">                assert(num_cub_points==cub::numCubPoints());</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                <span class="comment">//TODO dimensions should be generic</span></div><div class="line">                <span class="keywordflow">for</span>(short_t coord=0; coord&lt; shape_property&lt;Geometry::parent_shape&gt;::dimension; ++coord)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line">                    {</div><div class="line">                        eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) = 0.;</div><div class="line">                        <span class="keywordflow">for</span> (int_t dof=0; dof &lt; basis_cardinality ; ++dof)</div><div class="line">                        {</div><div class="line">                          eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) += </div><div class="line">                            eval(grid_points(point_dim+dof,coord_dim+coord)*!phi(dof,cub_point,0));</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }                </div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">//[cubature_point_grid_generation]</span></div><div class="line"></div><div class="line">        <span class="comment">//[function_evaluation]</span></div><div class="line"><span class="comment"></span>        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>function_evaluation {</div><div class="line">          </div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; function_values;</div><div class="line">            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, function_values&gt; arg_list;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                </div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;3&gt;(grid_points());</div><div class="line">                </div><div class="line">                <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line">                {</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+cub_point,coord_dim+0));</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+cub_point,coord_dim+1));</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+cub_point,coord_dim+2));</div><div class="line"></div><div class="line">                  eval(function_values(point_dim+cub_point)) = FunctionDefinition::compute(x,y,z);</div><div class="line">                }                </div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">//[function_evaluation]</span></div><div class="line"></div><div class="line">        <span class="comment">//[quartic_source]</span></div><div class="line">        <span class="keyword">struct </span>quartic_source {</div><div class="line">            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line">          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line">                <span class="keywordflow">return</span> 4.*(i_x*i_x*i_x*i_x + i_y*i_y*i_y*i_y + i_z*i_z*i_z*i_z);</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">//[quartic_source]</span></div><div class="line"></div><div class="line">        <span class="comment">//[quadratic_boundary_value]</span></div><div class="line">        <span class="keyword">struct </span>quadratic_boundary_value {</div><div class="line">            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line">          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line">                <span class="keywordflow">return</span> i_x*i_x + i_y*i_y + i_z*i_z;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">//[quadratic_boundary_value]</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// TODO: move this functor to interpolate.hpp</span></div><div class="line">        <span class="comment">// [not_normalized_transform]</span></div><div class="line">        <span class="keyword">struct </span>not_normalized_transform {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> jac_det=gt::accessor&lt;0, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> weights   =gt::accessor&lt;1, enumtype::inout, gt::extent&lt;&gt; , 3&gt; ;</div><div class="line">            <span class="keyword">using</span> phi   =gt::accessor&lt;2, enumtype::in   , gt::extent&lt;&gt; , 3&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> in   =gt::accessor&lt;3, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> out   =gt::accessor&lt;4, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; jac_det, weights, phi, in, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; qp;</div><div class="line">                gt::dimension&lt;5&gt; dimx;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line">                uint_t <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line">                </div><div class="line">                <span class="keywordflow">for</span>(short_t P_i=0; P_i&lt;basis_cardinality; ++P_i) <span class="comment">// current dof</span></div><div class="line">                {</div><div class="line">                    eval(out((uint_t)0,(uint_t)0,(uint_t)0,(uint_t)P_i))=0.;</div><div class="line">                    <span class="keywordflow">for</span>(short_t q=0; q&lt;num_cub_points; ++q){</div><div class="line">                      assert(eval(jac_det(qp+q)));</div><div class="line">                      eval(out((uint_t)0,(uint_t)0,(uint_t)0,(uint_t)P_i))  +=</div><div class="line">                        eval(!phi(P_i,q,0)*in(qp+q)*!weights(q,0,0)*jac_det(qp+q));</div><div class="line"></div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">// [not_normalized_transform]</span></div><div class="line"></div><div class="line">        <span class="comment">// TODO: refactoring of bc application functors required</span></div><div class="line">        <span class="comment">// TODO: avoid overlap in assignement/computation</span></div><div class="line">        <span class="comment">// [apply_dirichlet_boundary_conditions_top]</span></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_top {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,0,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,0,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,0,I1),dof2+indexing.index(J1,0,I1))) = 1.;</div><div class="line">                        </div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,0,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">// [apply_dirichlet_boundary_conditions_top]</span></div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_bottom {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,N_DOF1-1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,N_DOF1-1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,N_DOF1-1,I1),dof2+indexing.index(J1,N_DOF1-1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,N_DOF1-1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line"></div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_left {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(0,J1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(0,J1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(0,J1,I1),dof2+indexing.index(0,J1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(0,J1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_right {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(N_DOF2-1,J1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(N_DOF2-1,J1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(N_DOF2-1,J1,I1),dof2+indexing.index(N_DOF2-1,J1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(N_DOF2-1,J1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_front {</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                          eval(stiff(dof1+indexing.index(J1,I1,0),dof2+i)) = 0.;</div><div class="line">                          eval(stiff(dof2+indexing.index(J1,I1,0),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,I1,0),dof2+indexing.index(J1,I1,0))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,I1,0))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_rear {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,I1,N_DOF0-1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,I1,N_DOF0-1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,I1,N_DOF0-1),dof2+indexing.index(J1,I1,N_DOF0-1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,I1,N_DOF0-1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define PRINT_DATA_FILES true</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a36494.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(){</div><div class="line"></div><div class="line">    <span class="comment">// - In this example a Poisson problem in 3D is solved</span></div><div class="line">    <span class="comment">// - Homogeneous Dirichlet boundary conditions are imposed</span></div><div class="line">    <span class="comment">// - The source term is non null and defined according to the implementation of the FunctionDefinition template parameter of function_evaluation functor</span></div><div class="line">    <span class="comment">// - The FEM linear system is solved making use of the Conjugate Gradient method implemented in the cg_solver functor</span></div><div class="line">    <span class="comment">// - NOTE: have a look to the linear_solver example for correct usage of the available linear solver functors</span></div><div class="line">    <span class="comment">// - WARNING: this is a temporary example built to reproduce the results obtained with deal.II for the same problem (have a look to step-4.cc). </span></div><div class="line">    <span class="comment">//   For this reason we need the same dof ordering and this is obtained by using the reordered_grid and by activating the</span></div><div class="line">    <span class="comment">//   REORDER and DEAL_II_ORDERING flag in numerics/intrepid.hpp. At present this only works for order 1 Lagrange elements on Hexahedron so</span></div><div class="line">    <span class="comment">//   do not change this setup (FE choice).</span></div><div class="line">    <span class="comment">// - WARNING: at present the only elements available to the user for modification are the solver_setup, domain_definition,</span></div><div class="line">    <span class="comment">//   and boundary_value parameters together with the source definition</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">//[solver_setup]</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> stability_thr(-1.0);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> error_thr(1.e-20);</div><div class="line">    <span class="keywordtype">double</span> stability;</div><div class="line">    uint_t max_iter(10000);</div><div class="line">    <span class="comment">//[solver_setup]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain_definitions]</span></div><div class="line">    constexpr uint_t d1=4;</div><div class="line">    constexpr uint_t d2=4;</div><div class="line">    constexpr uint_t d3=4;</div><div class="line">    <span class="comment">//[domain_definitions]</span></div><div class="line"></div><div class="line">    <span class="comment">// WARNING: DO NOT MODIFY ANYTHING BELOW THIS LINE!!!</span></div><div class="line"></div><div class="line">    <span class="comment">//[FEM_definitions]</span></div><div class="line">    <span class="keyword">using</span> fe=<a class="code" href="a37734.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_map=<a class="code" href="a37734.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> cub=<a class="code" href="a37842.html">cubature&lt;2, fe::shape()&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_t = <a class="code" href="a37930.html">intrepid::geometry&lt;geo_map, cub&gt;</a>;</div><div class="line">    <span class="keyword">using</span> discr_t = <a class="code" href="a37922.html">intrepid::discretization&lt;fe, cub&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as=<a class="code" href="a37674.html">assembly&lt;geo_t&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as_base=<a class="code" href="a37698.html">assembly_base&lt;geo_t&gt;</a>;</div><div class="line">    constexpr uint_t dof_per_dim{2};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line">    constexpr uint_t dof_per_el{dof_per_dim*dof_per_dim*dof_per_dim};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line">    constexpr gridtools::uint_t n_dof{((dof_per_dim-1)*d1+1)*((dof_per_dim-1)*d2+1)*((dof_per_dim-1)*d3+1)};</div><div class="line">    constexpr gridtools::uint_t n_dofx{(dof_per_dim-1)*d1+1};</div><div class="line">    constexpr gridtools::uint_t n_dofy{(dof_per_dim-1)*d2+1};</div><div class="line">    constexpr gridtools::uint_t n_dofz{(dof_per_dim-1)*d3+1};</div><div class="line">    <span class="comment">//[FEM_definitions]</span></div><div class="line">    </div><div class="line">    <span class="comment">//[storages_definitions]</span></div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    <span class="keyword">using</span> stiffness_matrix_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> stiffness_matrix_type = gridtools::storage&lt;assemble_storage&lt; stiffness_matrix_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line">    <span class="keyword">using</span> source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> source_vector_type = gridtools::storage&lt;assemble_storage&lt; source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line">    <span class="keyword">using</span> interpolated_source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> interpolated_source_vector_type = gridtools::storage&lt;assemble_storage&lt; interpolated_source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source evaluation grid</span></div><div class="line">    <span class="keyword">using</span> source_evaluation_grid_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> source_evaluation_grid_type = storage_t&lt;source_evaluation_grid_storage_info_t&gt;;</div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    <span class="keyword">using</span> solution_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> solution_vector_type = gridtools::storage&lt;assemble_storage&lt; solution_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;</div><div class="line">    <span class="comment">//[storages_definitions]</span></div><div class="line"></div><div class="line">    <span class="comment">//[storages_allocation]</span></div><div class="line">    constexpr uint_t ass_d1{d1+1};</div><div class="line">    constexpr uint_t ass_d2{d2+1};</div><div class="line">    constexpr uint_t ass_d3{d3+1};</div><div class="line">    <span class="comment">// Computational domain: this is the domain used for linear system solution calculation namely the physical domain plus a 1 element halo (along all domain boundary faces)</span></div><div class="line">    constexpr uint_t comp_d1{d1+2};</div><div class="line">    constexpr uint_t comp_d2{d2+2};</div><div class="line">    constexpr uint_t comp_d3{d3+2};</div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    stiffness_matrix_storage_info_t stiffness_(comp_d1,comp_d2,comp_d3,dof_per_el,dof_per_el);</div><div class="line">    stiffness_matrix_type stiffness(stiffness_, <a class="code" href="a37642.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;stiffness&quot;</span>);<span class="comment">// This is the unassembled problem matrix</span></div><div class="line">    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line">    source_vector_storage_info_t source_values_(comp_d1,comp_d2,comp_d3,cub::numCubPoints());</div><div class="line">    source_vector_type source_values(source_values_, <a class="code" href="a37642.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;source_values&quot;</span>);<span class="comment">// These are the source values computed at cubature point of each mesh element </span></div><div class="line">    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line">    interpolated_source_vector_storage_info_t interpolated_source_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line">    interpolated_source_vector_type interpolated_source(interpolated_source_, <a class="code" href="a37642.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;interpolated source&quot;</span>);<span class="comment">// This is the unassembled right hand side vector</span></div><div class="line">    <span class="comment">// Source evaluation grid</span></div><div class="line">    source_evaluation_grid_storage_info_t source_evaluation_grid_(ass_d1,ass_d2,ass_d3,cub::numCubPoints(),3);</div><div class="line">    source_evaluation_grid_type source_evaluation_grid(source_evaluation_grid_,0,<span class="stringliteral">&quot;source_evaluation_grid&quot;</span>);<span class="comment">// This is the grid of cubature points on which the source is evaluated</span></div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    solution_vector_storage_info_t sol_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line">    solution_vector_type sol(sol_, <a class="code" href="a37642.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;sol&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div><div class="line">    <span class="comment">//[storages_allocation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computational_domain_coords]</span></div><div class="line">    <span class="keyword">auto</span> ass_with_halo_coords=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    ass_with_halo_coords.value_list[0] = 1;</div><div class="line">    ass_with_halo_coords.value_list[1] = ass_d3-1;</div><div class="line">    <span class="comment">//[computational_domain_coords]</span></div><div class="line"></div><div class="line">    <span class="comment">//[as_instantiation]</span></div><div class="line">    geo_t geo_;</div><div class="line">    discr_t fe_;</div><div class="line">    geo_.<a class="code" href="a37922.html#a79fd100ccc3f922a503fbbfd16c83891">compute</a>(Intrepid::OPERATOR_GRAD);<span class="comment">//redundants</span></div><div class="line">    <span class="comment">//    geo_.compute(Intrepid::OPERATOR_VALUE);</span></div><div class="line">    fe_.compute(Intrepid::OPERATOR_GRAD);</div><div class="line">    fe_.compute(Intrepid::OPERATOR_VALUE);</div><div class="line">    <span class="keyword">using</span> as=<a class="code" href="a37674.html">assembly&lt;geo_t&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as_base=<a class="code" href="a37698.html">assembly_base&lt;geo_t&gt;</a>;</div><div class="line">    as assembler( geo_, ass_d1, ass_d2, ass_d3);</div><div class="line">    as_base assembler_base(ass_d1, ass_d2, ass_d3);</div><div class="line">    <span class="comment">//[as_instantiation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[grid]</span></div><div class="line">    <span class="comment">//constructing a structured cartesian grid</span></div><div class="line">    <span class="keywordflow">for</span> (uint_t i=0; i&lt;ass_d1; i++)</div><div class="line">        <span class="keywordflow">for</span> (uint_t j=0; j&lt;ass_d2; j++)</div><div class="line">            <span class="keywordflow">for</span> (uint_t k=0; k&lt;ass_d3; k++){</div><div class="line">                <span class="keywordflow">for</span> (uint_t point=0; point&lt;geo_map::basis_cardinality(); point++)</div><div class="line">                {</div><div class="line">                    <span class="comment">// TODO: here we use the reordered_grid method in order to have the same dof ordering of deal.II</span></div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  0)= (2*i + geo_.reordered_grid()(point, 0, 0) - 1.);</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  1)= (2*j + geo_.reordered_grid()(point, 1, 0) - 1.);</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  2)= (2*k + geo_.reordered_grid()(point, 2, 0) - 1.);</div><div class="line">                }</div><div class="line">            }</div><div class="line">    <span class="comment">//[grid]</span></div><div class="line"></div><div class="line">    <span class="comment">//[source_term_calculation]    </span></div><div class="line">    <span class="comment">// In this part we compute the source term of the FEM linear system, performed in the following steps:</span></div><div class="line">    <span class="comment">// 1) generation of the grid of cubature points on the mesh elements, starting from the cubature points of the reference element</span></div><div class="line">    <span class="comment">// 2) evaluation of the source function on the generated cubature point grid</span></div><div class="line">    <span class="comment">// 3) calculation of the integrals between source function and basis functions, for all mesh elements</span></div><div class="line"></div><div class="line">    <span class="comment">//[steps_1_2]</span></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, typename discr_t::basis_function_storage_t&gt; p_phi_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, source_evaluation_grid_type&gt; p_source_evaluation_grid_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, source_vector_type&gt; p_source_values_src;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_src,p_phi_src,p_source_evaluation_grid_src,p_source_values_src&gt; source_eval_domain_accessors;</div><div class="line">    gt::aggregator_type&lt;source_eval_domain_accessors&gt; source_eval_domain(boost::fusion::make_vector(&amp;assembler_base.grid(), </div><div class="line">                                                                                                    &amp;fe_.val(),</div><div class="line">                                                                                                    &amp;source_evaluation_grid,</div><div class="line">                                                                                                    &amp;source_values));</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    </div><div class="line">    <span class="comment">//[source_eval]</span></div><div class="line">    <span class="keyword">auto</span> source_eval=gt::make_computation&lt;BACKEND&gt;(source_eval_domain,</div><div class="line">                                                   ass_with_halo_coords,</div><div class="line">                                                   make_multistage(</div><div class="line">                                                       execute&lt;forward&gt;(),</div><div class="line">                                                       gt::make_stage&lt;<a class="code" href="a37326.html">gdl::functors::cubature_point_grid_generation&lt;geo_t&gt;</a> &gt;( </div><div class="line">                                                           p_grid_points_src(),</div><div class="line">                                                           p_phi_src(),</div><div class="line">                                                           p_source_evaluation_grid_src()),</div><div class="line">                                                       gt::make_stage&lt;<a class="code" href="a37330.html">gdl::functors::function_evaluation&lt;gdl::functors::quartic_source&gt;</a> &gt;(</div><div class="line">                                                           p_source_evaluation_grid_src(),</div><div class="line">                                                           p_source_values_src())</div><div class="line">                                                                   ));</div><div class="line">    source_eval-&gt;ready();</div><div class="line">    source_eval-&gt;steady();</div><div class="line">    source_eval-&gt;run();</div><div class="line">    source_eval-&gt;finalize();</div><div class="line">    <span class="comment">//[source_eval]</span></div><div class="line">    <span class="comment">//[steps_1_2]</span></div><div class="line">  </div><div class="line"></div><div class="line">    <span class="comment">//[steps_3]</span></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, discr_t::grad_storage_t&gt; p_dphi_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, as::jacobian_type&gt; p_jac_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, as::storage_type&gt; p_jac_det_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;4, as::weights_storage_t&gt; p_weights_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;5, typename discr_t::basis_function_storage_t&gt; p_phi_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;6, source_vector_type&gt; p_source_values_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;7, interpolated_source_vector_type&gt; p_interpolated_source_values_interp;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_interp, p_dphi_interp, p_jac_interp, p_jac_det_interp, p_weights_interp, p_phi_interp, p_source_values_interp, p_interpolated_source_values_interp&gt; source_interp_domain_accessors;</div><div class="line">    gt::aggregator_type&lt;source_interp_domain_accessors&gt; source_interp_domain(boost::fusion::make_vector(&amp;assembler_base.grid(), </div><div class="line">                                                                                                        &amp;fe_.grad(), </div><div class="line">                                                                                                        &amp;assembler.jac(), </div><div class="line">                                                                                                        &amp;assembler.jac_det(), </div><div class="line">                                                                                                        &amp;assembler.cub_weights(), </div><div class="line">                                                                                                        &amp;fe_.val(), </div><div class="line">                                                                                                        &amp;source_values, </div><div class="line">                                                                                                        &amp;interpolated_source));</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    </div><div class="line">    <span class="comment">//[source_interp]</span></div><div class="line">    <span class="comment">// TODO: merge step 1-2-3</span></div><div class="line">    <span class="keyword">auto</span> source_interp=gt::make_computation&lt;BACKEND&gt;(source_interp_domain,</div><div class="line">                                                     ass_with_halo_coords,</div><div class="line">                                                     gridtools::make_multistage(</div><div class="line">                                                         gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">                                                         gt::make_stage&lt;<a class="code" href="a37378.html">gdl::functors::update_jac&lt;geo_t&gt;</a> &gt;( p_grid_points_interp(), p_dphi_interp(), p_jac_interp()),</div><div class="line">                                                         gt::make_stage&lt;<a class="code" href="a37386.html">gdl::functors::det&lt;geo_t&gt;</a> &gt;(p_jac_interp(), p_jac_det_interp()),</div><div class="line">                                                         gridtools::make_stage&lt;gdl::functors::not_normalized_transform&gt;(p_jac_det_interp(), p_weights_interp(), p_phi_interp(), p_source_values_interp(), p_interpolated_source_values_interp())</div><div class="line">                                                                                ));</div><div class="line">    source_interp-&gt;ready();</div><div class="line">    source_interp-&gt;steady();</div><div class="line">    source_interp-&gt;run();</div><div class="line">    source_interp-&gt;finalize();</div><div class="line">    <span class="comment">//[source_interp]</span></div><div class="line">    <span class="comment">//[steps_3]</span></div><div class="line">    <span class="comment">//[source_term_calculation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[stiffness_calculation]</span></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, discr_t::grad_storage_t&gt; p_dphi;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, discr_t::grad_storage_t&gt; p_dpsi;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, as::jacobian_type&gt; p_jac;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, as::storage_type&gt; p_jac_det;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;4, as::jacobian_type&gt; p_jac_inv;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;5, as::weights_storage_t&gt; p_weights;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;6, stiffness_matrix_type&gt; p_stiffness;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_dphi, p_dpsi, p_jac, p_jac_det, p_jac_inv, p_weights, p_stiffness&gt; stiffness_calculation_domain_accessors;</div><div class="line">    gridtools::aggregator_type&lt;stiffness_calculation_domain_accessors&gt; stiffness_calculation_domain(boost::fusion::make_vector(&amp;fe_.grad(), </div><div class="line">                                                                                                                               &amp;fe_.grad(), </div><div class="line">                                                                                                                               &amp;assembler.jac(), </div><div class="line">                                                                                                                               &amp;assembler.jac_det(), </div><div class="line">                                                                                                                               &amp;assembler.jac_inv(), </div><div class="line">                                                                                                                               &amp;assembler.cub_weights(), </div><div class="line">                                                                                                                               &amp;stiffness));</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> compute_stiffness=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        stiffness_calculation_domain,</div><div class="line">        ass_with_halo_coords,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37402.html">gdl::functors::inv&lt;geo_t&gt;</a> &gt;(p_jac(), p_jac_det(), p_jac_inv()),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37570.html">gdl::functors::stiffness&lt;fe, cub&gt;</a> &gt;(p_jac_det(), p_jac_inv(), p_weights(), p_dphi(), p_dpsi(), p_stiffness())<span class="comment">//stiffness</span></div><div class="line">        ));</div><div class="line">    compute_stiffness-&gt;ready();</div><div class="line">    compute_stiffness-&gt;steady();</div><div class="line">    compute_stiffness-&gt;run();</div><div class="line">    compute_stiffness-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]</span></div><div class="line">    <span class="comment">//[stiffness_calculation]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[boundary_condition_application]</span></div><div class="line">        </div><div class="line">    <span class="comment">// IMPORTANT NOTE: here we introduce the Dirichlet boundary conditions, by requiring to the solution to have a given value on the domain boundary. With an assembled </span></div><div class="line">    <span class="comment">// stiffness matrix and source vector we would set to 0 all the matrix elements of the rows corresponding to a boundary dof except for the diagonal element, whose value</span></div><div class="line">    <span class="comment">// would be instead set to 1. On the source vector we would then introduce the boundary condition by setting the boundary elements equal to the defined solution values. </span></div><div class="line">    <span class="comment">// In our case we have unassembled stiffness matrix and source vector, however the same strategy works: introducing the above modifications to the local stifness matrices </span></div><div class="line">    <span class="comment">// and source vectors we look for the solution of a linear system identical to the one of the assembled case except for a multiplicative factor for the rows corresponding </span></div><div class="line">    <span class="comment">// to the boundary dofs, the factor value being equal to the number of mesh elements sharing the dof itself. Since this factor, for a given row, is the same for the </span></div><div class="line">    <span class="comment">// stiffness matrix and the source vector the problem solution does not change.</span></div><div class="line"></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_bc;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, stiffness_matrix_type&gt; p_stiffness_bc;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, interpolated_source_vector_type&gt; p_interpolated_source_bc;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    </div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_bc,p_stiffness_bc,p_interpolated_source_bc&gt; bc_application_domain_accessors;</div><div class="line">    <span class="comment">// TODO: what about basis of order higher than 2? Do we have to generate the grid of internal dofs?</span></div><div class="line">    gridtools::aggregator_type&lt;bc_application_domain_accessors&gt; bc_application_domain(boost::fusion::make_vector(&amp;assembler_base.grid(),&amp;stiffness,&amp;interpolated_source));</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// TODO: rename front/rear/etc with coords xy,z=0, etc</span></div><div class="line">    <span class="comment">// TODO: avoid multiple declaration of stencils and grids</span></div><div class="line"></div><div class="line">    <span class="comment">// Top boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_top]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_top=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, 1, 2});</div><div class="line">    bc_application_domain_coords_top.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_top.value_list[1] = ass_d3-1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_top]</span></div><div class="line"></div><div class="line">    <span class="comment">//[apply_bc_top]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_top=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_top,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37346.html">gdl::functors::apply_dirichlet_boundary_conditions_top&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_top-&gt;ready();</div><div class="line">    apply_bc_top-&gt;steady();</div><div class="line">    apply_bc_top-&gt;run();</div><div class="line">    apply_bc_top-&gt;finalize();</div><div class="line">    <span class="comment">//[apply_bc_top]    </span></div><div class="line"></div><div class="line">    <span class="comment">// Bottom boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_bottom]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_bottom=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, d2, d2, 2});</div><div class="line">    bc_application_domain_coords_bottom.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_bottom.value_list[1] = ass_d3-1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_bottom]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_bottom=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_bottom,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37350.html">gdl::functors::apply_dirichlet_boundary_conditions_bottom&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_bottom-&gt;ready();</div><div class="line">    apply_bc_bottom-&gt;steady();</div><div class="line">    apply_bc_bottom-&gt;run();</div><div class="line">    apply_bc_bottom-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line"></div><div class="line">    <span class="comment">// Left boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_left]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_left=gridtools::grid&lt;axis&gt;({1, 0, 1, 1, 2},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_left.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_left.value_list[1] = ass_d3-1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_left]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_left=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_left,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37354.html">gdl::functors::apply_dirichlet_boundary_conditions_left&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_left-&gt;ready();</div><div class="line">    apply_bc_left-&gt;steady();</div><div class="line">    apply_bc_left-&gt;run();</div><div class="line">    apply_bc_left-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line"></div><div class="line">    <span class="comment">// Right boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_right]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_right=gridtools::grid&lt;axis&gt;({1, 0, d1, d1, 2},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_right.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_right.value_list[1] = ass_d3-1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_right]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_right=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_right,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37358.html">gdl::functors::apply_dirichlet_boundary_conditions_right&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_right-&gt;ready();</div><div class="line">    apply_bc_right-&gt;steady();</div><div class="line">    apply_bc_right-&gt;run();</div><div class="line">    apply_bc_right-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line"></div><div class="line">    <span class="comment">// Front boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_front]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_front=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_front.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_front.value_list[1] = 1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_front]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_front=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_front,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37362.html">gdl::functors::apply_dirichlet_boundary_conditions_front&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_front-&gt;ready();</div><div class="line">    apply_bc_front-&gt;steady();</div><div class="line">    apply_bc_front-&gt;run();</div><div class="line">    apply_bc_front-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line"></div><div class="line">    <span class="comment">// Rear boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_rear]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_rear=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_rear.value_list[0] = d3;</div><div class="line">    bc_application_domain_coords_rear.value_list[1] = d3;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_rear]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line">    <span class="keyword">auto</span> apply_bc_rear=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_rear,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a class="code" href="a37366.html">gdl::functors::apply_dirichlet_boundary_conditions_rear&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_rear-&gt;ready();</div><div class="line">    apply_bc_rear-&gt;steady();</div><div class="line">    apply_bc_rear-&gt;run();</div><div class="line">    apply_bc_rear-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]    </span></div><div class="line"></div><div class="line">    <span class="comment">//[boundary_condition_application]</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">//[linear_system_solution]</span></div><div class="line">    <a class="code" href="a37962.html">linear_solver&lt; gdl::cg_solver&lt;dof_per_dim, dof_per_dim, dof_per_dim&gt;</a> &gt;::solve(stiffness, interpolated_source, sol, stability_thr, error_thr, max_iter);</div><div class="line">    <span class="comment">//[linear_system_solution]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#if PRINT_DATA_FILES</span></div><div class="line">    </div><div class="line">    <span class="comment">//[print_problem]</span></div><div class="line">    <span class="comment">// In order to compare the obtained linear system and the computed solution with other solver, we perform the assembly of stiffness matrix, source vector and solution vector </span></div><div class="line">    <span class="comment">//[print_storages_definitions]</span></div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    <span class="keyword">using</span> assembled_stiffness_matrix_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> assembled_stiffness_matrix_type = gridtools::storage&lt;assemble_storage&lt; assembled_stiffness_matrix_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source vector</span></div><div class="line">    <span class="keyword">using</span> assembled_source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> assembled_source_vector_type = gridtools::storage&lt;assemble_storage&lt; assembled_source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    <span class="comment">//[print_storages_definitions]</span></div><div class="line"></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, stiffness_matrix_type&gt; p_unass_stiffness;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, stiffness_matrix_type&gt; p_ass_stiffness;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, interpolated_source_vector_type&gt; p_unass_source;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, interpolated_source_vector_type&gt; p_ass_source;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_unass_stiffness, p_ass_stiffness, p_unass_source, p_ass_source&gt; ass_domain_accessors;</div><div class="line">    gridtools::aggregator_type&lt;ass_domain_accessors&gt; ass_domain(boost::fusion::make_vector(&amp;stiffness,&amp;stiffness,&amp;interpolated_source,&amp;interpolated_source));</div><div class="line">    <span class="keyword">auto</span> ass_grid=gridtools::grid&lt;axis&gt;({1, 0, 1, interpolated_source.meta_data().template dim&lt;0&gt;()-1, interpolated_source.meta_data().template dim&lt;0&gt;()},</div><div class="line">        {1, 0, 1, interpolated_source.meta_data().template dim&lt;1&gt;()-1, interpolated_source.meta_data().template dim&lt;1&gt;()});</div><div class="line">    ass_grid.value_list[0] = 1;</div><div class="line">    ass_grid.value_list[1] = interpolated_source.meta_data().template dim&lt;2&gt;()-1;</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line"></div><div class="line">    <span class="comment">//[assembly_computation]</span></div><div class="line">    <span class="keyword">auto</span> compute_assemble=gridtools::make_computation&lt;BACKEND&gt;(ass_domain,</div><div class="line">                                                               ass_grid,</div><div class="line">                                                               gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_assemble&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_unass_stiffness(),p_ass_stiffness()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_matrix_distribute&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_ass_stiffness()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_vector_assemble&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_unass_source(),p_ass_source()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_vector_distribute&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_ass_source())</div><div class="line">                                                                                    ));</div><div class="line">    compute_assemble-&gt;ready();</div><div class="line">    compute_assemble-&gt;steady();</div><div class="line">    compute_assemble-&gt;run();</div><div class="line">    compute_assemble-&gt;finalize();</div><div class="line">    <span class="comment">//[assembly_computation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[print_lienar_system_on_files]</span></div><div class="line">    std::ofstream A_matrix;</div><div class="line">    A_matrix.open(<span class="stringliteral">&quot;A_matrix.dat&quot;</span>);        </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</span></div><div class="line"><span class="comment">        for(uint_t dof2 = 0;dof2&lt;n_dof;++dof2)</span></div><div class="line"><span class="comment">            A_matrix&lt;&lt;(stiffness.get_pointer_to_use())-&gt;get_value(dof1,dof2)&lt;&lt;&quot; &quot;;</span></div><div class="line"><span class="comment">    }</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   </div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;ass_d1;++i)</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=1;j&lt;ass_d2;++j)</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1;k&lt;ass_d3;++k){</div><div class="line">          A_matrix&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;k&lt;&lt;std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;dof_per_el;++dof1){</div><div class="line">              <span class="keywordflow">for</span>(uint_t dof2 = 0;dof2&lt;dof_per_el;++dof2){</div><div class="line">   </div><div class="line">              </div><div class="line"></div><div class="line">              <span class="comment">// DOF coords based access</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_z = 0;dof1_z&lt;dof_per_dim;++dof1_z)</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_y = 0;dof1_y&lt;dof_per_dim;++dof1_y)</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_x = 0;dof1_x&lt;dof_per_dim;++dof1_x)</span></div><div class="line">             <span class="comment">//  {</span></div><div class="line">               </div><div class="line">             <span class="comment">//  const uint_t dof1 = dof1_x + dof1_y*dof_per_dim + dof1_z*dof_per_dim*dof_per_dim;</span></div><div class="line">               </div><div class="line">             <span class="comment">//  for(uint_t dof2_z = 0;dof2_z&lt;dof_per_dim;++dof2_z)</span></div><div class="line">             <span class="comment">//  for(uint_t dof2_y = 0;dof2_y&lt;dof_per_dim;++dof2_y)</span></div><div class="line">             <span class="comment">//  for(uint_t dof2_x = 0;dof2_x&lt;dof_per_dim;++dof2_x){</span></div><div class="line">               </div><div class="line">             <span class="comment">//  const uint_t dof2 = dof2_x + dof2_y*dof_per_dim + dof2_z*dof_per_dim*dof_per_dim;</span></div><div class="line">             </div><div class="line">                </div><div class="line">                </div><div class="line">                A_matrix&lt;&lt;stiffness(i,j,k,dof1,dof2)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>;</div><div class="line">                </div><div class="line">              }</div><div class="line">              A_matrix&lt;&lt;std::endl;</div><div class="line">              </div><div class="line">          }</div><div class="line">          A_matrix&lt;&lt;std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    A_matrix.close();</div><div class="line">    </div><div class="line">    </div><div class="line">    std::ofstream b_vector;</div><div class="line">    b_vector.open(<span class="stringliteral">&quot;b_vector.dat&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">      <span class="comment">//      b_vector&lt;&lt;(interpolated_source.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;&quot; &quot;;</span></div><div class="line">      b_vector&lt;&lt;dof1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;(interpolated_source.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(int i=1;i&lt;ass_d1;++i)</span></div><div class="line"><span class="comment">      for(int j=1;j&lt;ass_d2;++j)</span></div><div class="line"><span class="comment">        for(int k=1;k&lt;ass_d3;++k){</span></div><div class="line"><span class="comment">          b_vector&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">          for(uint_t dof1 = 0;dof1&lt;dof_per_el;++dof1){</span></div><div class="line"><span class="comment">            b_vector&lt;&lt;interpolated_source(i,j,k,dof1)&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">          }</span></div><div class="line"><span class="comment">          b_vector&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">        }</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    b_vector.close();</div><div class="line">    </div><div class="line">    std::ofstream x_vector;</div><div class="line">    x_vector.open(<span class="stringliteral">&quot;x_vector.dat&quot;</span>);</div><div class="line">    x_vector&lt;&lt;std::setprecision(16);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">      <span class="comment">//x_vector&lt;&lt;(sol.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;&quot; &quot;;</span></div><div class="line">      x_vector&lt;&lt;dof1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;(sol.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line">    x_vector.close();</div><div class="line">    <span class="comment">//[print_lienar_system_on_files]</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 3 2017 10:06:54 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
