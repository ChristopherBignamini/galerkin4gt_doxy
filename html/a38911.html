<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Conjugate Gradient linear solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a38911.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Conjugate Gradient linear solver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we compute the solution of a linear system making use of a linear solver provided by Galerkin4GT library and of the Conjugate Gradient method. The provided linear solvers are designed to correctly work in the context of FEM problems and in particular of how they are implemented in Galerkin4GT library. As already discussed (TODO: check this), in order to avoid performance issues we avoid the assembly step usually involving FEM matrices and vector: the implementation of the provided finite element solvers reflects this strategy and therefore they expect in input matrices and vectors, representing the FEM linear system, in the unassembled form.</p>
<p>The example starts with the initialization of some variables related to the usage of the linear solver: </p><div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keyword">const</span> float_t cumulative_error_check{1e-7};</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keyword">const</span> float_t max_relative_error_check{0.5};<span class="comment">// This is in %</span></div></div><!-- fragment --><p>and </p><div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> stability_thr(-1.0);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> error_thr(1.e-20);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">const</span> <a class="code" href="a38313.html">uint_t</a> max_iter(20000);</div><div class="ttc" id="a38313_html"><div class="ttname"><a href="a38313.html">uint_t</a></div></div>
</div><!-- fragment --><p>The first two variables will be used during solution correctness check at the end of the example, as threshold for cumulative (<code>cumulative_error_check</code>) and maximum (<code>max_relative_error_check</code>) discrepancy between the exact solution of the considered linear system and the one computed by the used solver. The second block of variables are instead configuration parameters for the conjugate gradient solver and we will discuss their meaning together with the linear solver interface description.</p>
<p>The next step of the example is represented by the intantiation of the storages involved in the definition of the linear system, namely a matrix and two vectors for rhs and unknowns respectively: </p><div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">// Problem matrix</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">using</span> matrix_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keyword">using</span> matrix_type=storage_t&lt; matrix_storage_info_t &gt;;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    matrix_storage_info_t A_(d1,d2,d3,d4,d4);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    matrix_type A(A_, 0.e0, <span class="stringliteral">&quot;A&quot;</span>);<span class="comment">// This is the unassembled problem matrix</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="comment">// RHS vector</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">using</span> rhs_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keyword">using</span> rhs_vector_type=storage_t&lt; rhs_vector_storage_info_t &gt;;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    rhs_vector_storage_info_t b_(d1,d2,d3,d4);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    rhs_vector_type b(b_, 0.e0, <span class="stringliteral">&quot;b&quot;</span>);<span class="comment">// This is the unassembled right hand side vector</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="comment">// Unknowns vector</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">//[assemble_storage]</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keyword">using</span> unk_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keyword">using</span> unk_vector_type = storage&lt;assemble_storage&lt; unk_vector_storage_info_t, dof_per_dim_0, dof_per_dim_1, dof_per_dim_2&gt; &gt;;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    unk_vector_storage_info_t x_(d1,d2,d3,d4);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    unk_vector_type x(x_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;x&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="comment">//[assemble_storage]</span></div></div><!-- fragment --><p>We will not discuss the roles of the <code>storage_info</code> and <code>storage_t</code> types in the definition of linear system matrix and rhs storage definition since they have been already used in previous examples. However is worth providing some details concerning the types used for the unknowns vector: </p><div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keyword">using</span> unk_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keyword">using</span> unk_vector_type = storage&lt;assemble_storage&lt; unk_vector_storage_info_t, dof_per_dim_0, dof_per_dim_1, dof_per_dim_2&gt; &gt;;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    unk_vector_storage_info_t x_(d1,d2,d3,d4);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    unk_vector_type x(x_, halo_data(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;x&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div></div><!-- fragment --><p>As it can be seen in the above snippet we are using as usual the <code>storage_info</code> type for the definition of the layout but, for the storage type <code>unk_vector_type</code>, we use of the new type <code>assemble_storage &lt;...&gt;</code> as template parameter for the GridTools <code>storage</code> type: the <code>assemble_storage</code> type derives from GridTools basic storage type and provides additional methods to access the stored elements making use of a single global dof or global dof pairs (depending on the storage rank) as we would do with assembled FEM matrix and vector, instead of using the standard storage access method requiring the tuple of indexes identifying the position of the mesh element and the dof or dof pair of the specific element. This storage allows also to introduce the presence of an halo of mesh element only used for computational purposes without a real physical meaning. This property, particularly useful for the available lineas solvers, can be used by providing a <code>halo_data</code> input parameter type which takes in input as constructor parameters the total halo size along the spatial dimensions and the corresponding sizes on the "left" sides.</p>
<p>The next step is represented by the generation of a random linear system, according to the following strategy: the matrix <code>A</code> of the system is randomly generated as A=Z*Z' where Z is in its turn randomly generated. We randomly generate also the unknowns vector <code>x</code> and then the rhs vector <code>b</code> is computed as <code>b = Ax</code>. The first step of this procedure is the generation of the random problem matrix and of solution (unknowns) vector, performed as: </p><div class="fragment"></div><!-- fragment --><p>and </p><div class="fragment"></div><!-- fragment --><ul>
<li>A and b vector are unassembled while the solution x will be provided in assembled form and when a non zero starting point is provided, in the same variable, it must be in its assembled form</li>
<li>"left" and "right" halos are expected to be present in the provided data: if d1, d2, d3 and d4 are the provided storage sizes, the problem is solved for the "physical" central d1-2, d2-2, d3-2 and d4-2 elements</li>
<li>A and b elements for halo element must be set to zero</li>
</ul>
<h1>Full Code </h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">// TODO: clean include list, assembly.hpp should not be here</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assembly.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assemble_storage.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/linear_solver.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a36802.html">gridtools</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a36798.html">gdl</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a36804.html">gdl::enumtype</a>;</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_per_dim_0(3);</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_per_dim_1(3);</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_per_dim_2(3);</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d1=3;</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d2=3;</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d3=3;</div><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d4=dof_per_dim_0*dof_per_dim_1*dof_per_dim_2;</div><div class="line"></div><div class="line">constexpr gridtools::uint_t n_dof{((dof_per_dim_0-1)*(d1-2)+1)*((dof_per_dim_1-1)*(d2-2)+1)*((dof_per_dim_2-1)*(d3-2)+1)};</div><div class="line"></div><div class="line"><span class="preprocessor">#define PRINT_DATA_FILES true</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a36500.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div><div class="line"></div><div class="line">    <span class="comment">// - In this example a linear problem Ax=b is solved using conjugate gradient method</span></div><div class="line">    <span class="comment">// - A and b vector are unassembled while the solution x will be provided in assembled</span></div><div class="line">    <span class="comment">// form and when a non zero starting point is provided, in the same variable, it must</span></div><div class="line">    <span class="comment">// be in its assembled form</span></div><div class="line">    <span class="comment">// - The A matrix is randomly generated as A=Z*Z&#39; where Z is in its turn randomly generated,</span></div><div class="line">    <span class="comment">// this ensure A to be invertible. b vector is randomly generated too as b = Ax where the</span></div><div class="line">    <span class="comment">// problem solution x is also random.</span></div><div class="line">    <span class="comment">// - &quot;left&quot; and &quot;right&quot; halos are expected to be present in the provided data: if</span></div><div class="line">    <span class="comment">// d1, d2, d3 and d4 are the provided storage sizes, the problem is solved for the</span></div><div class="line">    <span class="comment">// &quot;physical&quot; central d1-2, d2-2, d3-2 and d4-2 elements</span></div><div class="line">    <span class="comment">// - A and b elements for halo element must be set to zero</span></div><div class="line">    <span class="comment">// - Setting PRINT_DATA_FILES to true, files containing the assembled A,b and x data</span></div><div class="line">    <span class="comment">//   are produced. They can be used for cross check (e.g., vs python numpy solution)</span></div><div class="line">    <span class="comment">// TODO: last two condition must be removed from external solver interface</span></div><div class="line"></div><div class="line">    <span class="comment">//[test_check_values]</span></div><div class="line">    <span class="keyword">const</span> float_t cumulative_error_check{1e-7};</div><div class="line">    <span class="keyword">const</span> float_t max_relative_error_check{0.5};<span class="comment">// This is in %</span></div><div class="line">    <span class="comment">//[test_check_values]</span></div><div class="line"></div><div class="line">    <span class="comment">//[solver_setup]</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> stability_thr(-1.0);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> error_thr(1.e-20);</div><div class="line">    <span class="keyword">const</span> uint_t max_iter(20000);</div><div class="line">    <span class="comment">//[solver_setup]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[storages]</span></div><div class="line">    <span class="comment">// Problem matrix</span></div><div class="line">    <span class="keyword">using</span> matrix_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> matrix_type=storage_t&lt; matrix_storage_info_t &gt;;</div><div class="line">    matrix_storage_info_t A_(d1,d2,d3,d4,d4);</div><div class="line">    matrix_type A(A_, 0.e0, <span class="stringliteral">&quot;A&quot;</span>);<span class="comment">// This is the unassembled problem matrix</span></div><div class="line"></div><div class="line">    <span class="comment">// RHS vector</span></div><div class="line">    <span class="keyword">using</span> rhs_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> rhs_vector_type=storage_t&lt; rhs_vector_storage_info_t &gt;;</div><div class="line">    rhs_vector_storage_info_t b_(d1,d2,d3,d4);</div><div class="line">    rhs_vector_type b(b_, 0.e0, <span class="stringliteral">&quot;b&quot;</span>);<span class="comment">// This is the unassembled right hand side vector</span></div><div class="line"></div><div class="line">    <span class="comment">// Unknowns vector</span></div><div class="line">    <span class="comment">//[assemble_storage]</span></div><div class="line">    <span class="keyword">using</span> unk_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> unk_vector_type = storage&lt;assemble_storage&lt; unk_vector_storage_info_t, dof_per_dim_0, dof_per_dim_1, dof_per_dim_2&gt; &gt;;</div><div class="line">    unk_vector_storage_info_t x_(d1,d2,d3,d4);</div><div class="line">    unk_vector_type x(x_, <a class="code" href="a37727.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;x&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div><div class="line">    <span class="comment">//[assemble_storage]</span></div><div class="line">    <span class="comment">//[storages]</span></div><div class="line"></div><div class="line">    <span class="comment">//[random_generator_setup]</span></div><div class="line">    std::default_random_engine rand_eng;</div><div class="line">    std::uniform_real_distribution&lt;float_t&gt; rand_dist(0.e0,1.e0);</div><div class="line">    <span class="comment">//[random_generator_setup]</span></div><div class="line"></div><div class="line">    <span class="comment">//[random_problem_generation]</span></div><div class="line">    std::vector&lt;float_t&gt; A_rand(n_dof*n_dof);</div><div class="line">    std::vector&lt;float_t&gt; A_ext(n_dof*n_dof);</div><div class="line">    std::vector&lt;float_t&gt; x_ext(n_dof);</div><div class="line">    std::vector&lt;float_t&gt; b_ext(n_dof);</div><div class="line"></div><div class="line">    <span class="comment">// Generate random matrix</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t row=0;row&lt;n_dof;++row)</div><div class="line">        <span class="keywordflow">for</span>(uint_t col=0;col&lt;n_dof;++col)</div><div class="line">            A_rand[row*n_dof+col] = rand_dist(rand_eng);</div><div class="line"></div><div class="line">    <span class="comment">// Compute linear system matrix A_ext as A_rand*A_rand^T</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t row=0;row&lt;n_dof;++row)</div><div class="line">        <span class="keywordflow">for</span>(uint_t col=0;col&lt;n_dof;++col){</div><div class="line">            float_t sum = 0.;</div><div class="line">            <span class="keywordflow">for</span>(uint_t index=0;index&lt;n_dof;++index)</div><div class="line">                sum += A_rand[row*n_dof+index]*A_rand[col*n_dof+index];</div><div class="line">            A_ext[row*n_dof+col] = sum;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="comment">// Generate random solution</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t row=0;row&lt;n_dof;++row)</div><div class="line">        x_ext[row] = rand_dist(rand_eng);</div><div class="line"></div><div class="line">    <span class="comment">// Compute adjacency data (number of contributors for matrix each element)</span></div><div class="line">    std::vector&lt;int&gt; number_contributions_A(n_dof*n_dof,0);</div><div class="line">    std::vector&lt;int&gt; number_contributions_b(n_dof,0);</div><div class="line">    constexpr uint_t dof_per_dim(dof_per_dim_0);</div><div class="line">    constexpr uint_t d1_2{d1-2};</div><div class="line">    constexpr uint_t d2_2{d2-2};</div><div class="line">    constexpr uint_t d3_2{d3-2};</div><div class="line">    <span class="keywordflow">for</span> (uint_t i=0; i&lt;d1_2; i++)</div><div class="line">        <span class="keywordflow">for</span> (uint_t j=0; j&lt;d2_2; j++)</div><div class="line">            <span class="keywordflow">for</span> (uint_t k=0; k&lt;d3_2; k++)</div><div class="line">                <span class="keywordflow">for</span>(uint_t dofx1 = 0;dofx1&lt;dof_per_dim;++dofx1)</div><div class="line">                    <span class="keywordflow">for</span>(uint_t dofy1 = 0;dofy1&lt;dof_per_dim;++dofy1)</div><div class="line">                        <span class="keywordflow">for</span>(uint_t dofz1 = 0;dofz1&lt;dof_per_dim;++dofz1)</div><div class="line">                            <span class="keywordflow">for</span>(uint_t dofx2 = 0;dofx2&lt;dof_per_dim;++dofx2)</div><div class="line">                                <span class="keywordflow">for</span>(uint_t dofy2 = 0;dofy2&lt;dof_per_dim;++dofy2)</div><div class="line">                                    <span class="keywordflow">for</span>(uint_t dofz2 = 0;dofz2&lt;dof_per_dim;++dofz2){</div><div class="line"></div><div class="line">                                        assert((</div><div class="line">                                                i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                                j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                                k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)</div><div class="line">                                                )*n_dof</div><div class="line">                                                +</div><div class="line">                                                i*(dof_per_dim-1) + dofx2 +</div><div class="line">                                                j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy2*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                                k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz2*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)&lt;n_dof*n_dof);</div><div class="line"></div><div class="line">                                        number_contributions_A[</div><div class="line">                                            (</div><div class="line">                                            i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                            j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                            k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)</div><div class="line">                                            )*n_dof</div><div class="line">                                            +</div><div class="line">                                            i*(dof_per_dim-1) + dofx2 +</div><div class="line">                                            j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy2*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                            k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz2*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)]++;</div><div class="line">                                    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint_t i=0; i&lt;d1_2; i++)</div><div class="line">        <span class="keywordflow">for</span> (uint_t j=0; j&lt;d2_2; j++)</div><div class="line">            <span class="keywordflow">for</span> (uint_t k=0; k&lt;d3_2; k++)</div><div class="line">                <span class="keywordflow">for</span>(uint_t dofx1 = 0;dofx1&lt;dof_per_dim;++dofx1)</div><div class="line">                    <span class="keywordflow">for</span>(uint_t dofy1 = 0;dofy1&lt;dof_per_dim;++dofy1)</div><div class="line">                        <span class="keywordflow">for</span>(uint_t dofz1 = 0;dofz1&lt;dof_per_dim;++dofz1){</div><div class="line"></div><div class="line">                                assert(</div><div class="line">                                        i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                        j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                        k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)&lt;n_dof);</div><div class="line"></div><div class="line">                                number_contributions_b[</div><div class="line">                                    i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                    j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                    k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)</div><div class="line">                                    ]++;</div><div class="line">                            }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Build unassembled A matrix (shared contributions are split into equal parts)</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t i=0; i&lt;d1_2; i++)</div><div class="line">        <span class="keywordflow">for</span>(uint_t j=0; j&lt;d2_2; j++)</div><div class="line">            <span class="keywordflow">for</span>(uint_t k=0; k&lt;d3_2; k++)</div><div class="line">                <span class="keywordflow">for</span>(uint_t dofx1 = 0;dofx1&lt;dof_per_dim;++dofx1)</div><div class="line">                    <span class="keywordflow">for</span>(uint_t dofy1 = 0;dofy1&lt;dof_per_dim;++dofy1)</div><div class="line">                        <span class="keywordflow">for</span>(uint_t dofz1 = 0;dofz1&lt;dof_per_dim;++dofz1){</div><div class="line">                            <span class="keyword">const</span> uint_t dof1 = dofx1 + dofy1*dof_per_dim + dofz1*dof_per_dim*dof_per_dim;</div><div class="line">                            <span class="keywordflow">for</span>(uint_t dofx2 = 0;dofx2&lt;dof_per_dim;++dofx2)</div><div class="line">                                <span class="keywordflow">for</span>(uint_t dofy2 = 0;dofy2&lt;dof_per_dim;++dofy2)</div><div class="line">                                    <span class="keywordflow">for</span>(uint_t dofz2 = 0;dofz2&lt;dof_per_dim;++dofz2)</div><div class="line">                                    {</div><div class="line">                                        <span class="keyword">const</span> uint_t dof2 = dofx2 + dofy2*dof_per_dim + dofz2*dof_per_dim*dof_per_dim;</div><div class="line">                                        <span class="keyword">const</span> uint_t local_to_global =</div><div class="line">                                                (</div><div class="line">                                                i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                                j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                                k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)</div><div class="line">                                                )*n_dof</div><div class="line">                                                +</div><div class="line">                                                i*(dof_per_dim-1) + dofx2 +</div><div class="line">                                                j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy2*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                                k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz2*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1);</div><div class="line"></div><div class="line">                                        assert(local_to_global&lt;n_dof*n_dof);</div><div class="line"></div><div class="line">                                        A(i+1,j+1,k+1,dof1,dof2) = A_ext[local_to_global]/number_contributions_A[local_to_global];</div><div class="line">                                    }</div><div class="line">                        }</div><div class="line"></div><div class="line">    <span class="comment">// Reset unwanted (non-FEM) matrix element: these are the contributions</span></div><div class="line">    <span class="comment">// that would come from functions belonging to different mesh elements</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t row=0;row&lt;n_dof;++row)</div><div class="line">        <span class="keywordflow">for</span>(uint_t col=0;col&lt;n_dof;++col)</div><div class="line">            <span class="keywordflow">if</span>(number_contributions_A[row*n_dof+col]==0)</div><div class="line">                A_ext[row*n_dof+col] = 0.;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Compute random RHS</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t row=0;row&lt;n_dof;++row){</div><div class="line">        float_t sum = 0.;</div><div class="line">        <span class="keywordflow">for</span>(uint_t index=0;index&lt;n_dof;++index)</div><div class="line">            sum += A_ext[row*n_dof+index]*x_ext[index];</div><div class="line">        b_ext[row] = sum;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Build unassembled b vector (shared contributions are split into equal parts)</span></div><div class="line">    <span class="keywordflow">for</span>(uint_t i=0; i&lt;d1_2; i++)</div><div class="line">        <span class="keywordflow">for</span>(uint_t j=0; j&lt;d2_2; j++)</div><div class="line">            <span class="keywordflow">for</span>(uint_t k=0; k&lt;d3_2; k++)</div><div class="line">                <span class="keywordflow">for</span>(uint_t dofx1 = 0;dofx1&lt;dof_per_dim;++dofx1)</div><div class="line">                    <span class="keywordflow">for</span>(uint_t dofy1 = 0;dofy1&lt;dof_per_dim;++dofy1)</div><div class="line">                        <span class="keywordflow">for</span>(uint_t dofz1 = 0;dofz1&lt;dof_per_dim;++dofz1)</div><div class="line">                        {</div><div class="line">                            <span class="keyword">const</span> uint_t dof1 = dofx1 + dofy1*dof_per_dim + dofz1*dof_per_dim*dof_per_dim;</div><div class="line">                            <span class="keyword">const</span> uint_t local_to_global =</div><div class="line">                                    i*(dof_per_dim-1) + dofx1 +</div><div class="line">                                    j*((dof_per_dim-1)*d1_2 + 1)*(dof_per_dim-1) + dofy1*((dof_per_dim-1)*d1_2 + 1) +</div><div class="line">                                    k*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1)*(dof_per_dim-1) + dofz1*((dof_per_dim-1)*d1_2 + 1)*((dof_per_dim-1)*d2_2 + 1);</div><div class="line">                            assert(local_to_global&lt;n_dof);</div><div class="line">                            b(i+1,j+1,k+1,dof1) = b_ext[local_to_global]/number_contributions_b[local_to_global];</div><div class="line">                        }</div><div class="line"></div><div class="line">    <span class="comment">//[random_problem_generation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[solve]</span></div><div class="line">    <a class="code" href="a38047.html">linear_solver&lt; gdl::cg_solver&lt;dof_per_dim_0,dof_per_dim_1,dof_per_dim_2&gt;</a> &gt;::solve(A, b, x, stability_thr, error_thr, max_iter);</div><div class="line">    <span class="comment">//[solve]</span></div><div class="line"></div><div class="line">    <span class="comment">//[check_results]</span></div><div class="line">    <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;</div><div class="line">    float_t cumulative_error=0;</div><div class="line">    float_t max_relative_error=0;</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof = 0;dof&lt;n_dof;++dof) {</div><div class="line">        <span class="keyword">const</span> float_t cg_x(x.storage_pointer()-&gt;get_value(dof));</div><div class="line">        float_t relative_error(cg_x-x_ext[dof]);</div><div class="line">        cumulative_error += relative_error*relative_error;</div><div class="line">        <span class="keywordflow">if</span>(x_ext[dof]!=0){</div><div class="line">            relative_error /= x_ext[dof];</div><div class="line">            <span class="keywordflow">if</span>(std::abs(relative_error&gt;max_relative_error))</div><div class="line">                max_relative_error = relative_error;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Cumulative error = &quot;</span>&lt;&lt;cumulative_error&lt;&lt;std::endl;</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Max relative (abs) error = &quot;</span>&lt;&lt;max_relative_error*100&lt;&lt;std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(cumulative_error&gt;cumulative_error_check) {</div><div class="line">        success = <span class="keyword">false</span>;</div><div class="line">        std::cout&lt;&lt;<span class="stringliteral">&quot;Cumulative error check not passed, check value set to &quot;</span>&lt;&lt;cumulative_error_check&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(max_relative_error&gt;max_relative_error_check) {</div><div class="line">        success = <span class="keyword">false</span>;</div><div class="line">        std::cout&lt;&lt;<span class="stringliteral">&quot;Max relative error check not passed, check value set to &quot;</span>&lt;&lt;max_relative_error_check&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line">    <span class="comment">//[check_results]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#if PRINT_DATA_FILES</span></div><div class="line">    <span class="comment">//[print_result]</span></div><div class="line">    std::ofstream A_matrix;</div><div class="line">    A_matrix.open(<span class="stringliteral">&quot;A_matrix.dat&quot;</span>);</div><div class="line">    A_matrix&lt;&lt;std::setprecision(10);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">         <span class="keywordflow">for</span>(uint_t dof2 = 0;dof2&lt;n_dof;++dof2)</div><div class="line">             A_matrix&lt;&lt;A_ext[dof1*n_dof+dof2]&lt;&lt;<span class="stringliteral">&quot; &quot;</span>;</div><div class="line">    }</div><div class="line">    A_matrix.close();</div><div class="line"></div><div class="line">    std::ofstream b_vector;</div><div class="line">    b_vector.open(<span class="stringliteral">&quot;b_vector.dat&quot;</span>);</div><div class="line">    b_vector&lt;&lt;std::setprecision(10);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">            b_vector&lt;&lt;b_ext[dof1]&lt;&lt;<span class="stringliteral">&quot; &quot;</span>;</div><div class="line">    }</div><div class="line">    b_vector.close();</div><div class="line"></div><div class="line">    std::ofstream x_vector;</div><div class="line">    x_vector.open(<span class="stringliteral">&quot;x_vector.dat&quot;</span>);</div><div class="line">    x_vector&lt;&lt;std::setprecision(10);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">        x_vector&lt;&lt;x.storage_pointer()-&gt;get_value(dof1)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>;</div><div class="line">    }</div><div class="line">    x_vector.close();</div><div class="line"></div><div class="line">    <span class="comment">//[print_result]</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    assert(success);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue May 16 2017 17:44:05 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
