<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Discretization of an advection problem using modal DG (with Legendre Basis Functions)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a38920.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Discretization of an advection problem using modal DG (with Legendre Basis Functions) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Description </h1>
<p>Here we give an example of the implementation of a DG advection problem. This example is not fully developed, it is incomplete and not verified. it is intended as a first draft to show the main steps which are necessary for assembling a DG modal transient problem. It requires a basic understanding of GridTools, and it also requires the understanding of some of the examples, namely <a class="el" href="a38927.html">SEM Diagonal Local Mass Matrix (Using Legendre Basis Functions)</a>, <a class="el" href="a38924.html">Gather from neighbours</a>, <a class="el" href="a38921.html">DG Flux Implementation Example</a>.</p>
<p>The advised approach to this example is a test-driven one: instead of taking this example and changing it, start from scratch and follow step-by-step the implementation reported below, customizing it to your needs, and build your own example incrementally by checking at each step that everything works as expected.</p>
<p>One of the main problems of the GridTools library at its current status is the compilation time required when there are many input field. This is due to the heavy template metaprogramming done under the hood by GridTools to construct the computation graph. In this example we try to mitigate the compilation burden by splitting the code into several translation units, which are compiled separately into different object files (.o). These files are then linked together in the final executable. The advantage is that when changing one portion only its corresponding object file is recompiled.</p>
<p>The example is divided in 3 translation units, corresponding to the following headers:</p>
<ul>
<li>examples/legendre/compute_jacobian.hpp contains the computation of the jacobian matrices</li>
<li>examples/legendre/compute_assembly.hpp contains the assembly of the differential operators used in this example (i.e. the mass matrices).</li>
<li>examples/legendre/legendre.hpp contains the basic data structure for the problem. It also implements the time iteration.</li>
</ul>
<p>The files above generate an object file each. These objects are linked in examples/legendre/main.cpp and generate the final executable.</p>
<h1>Implementation </h1>
<h2>Target API </h2>
<p>We create the files legendre.hpp, compute_jacobian.hpp, compute_assembly.hpp, and create empty classes with "stub" constructors ad member functions (we will implement the details later):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>legendre_advection{</div><div class="line">      legendre_advection(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>){}</div><div class="line">      <span class="keywordtype">void</span> run(){}</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>compute_jacobian{</div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">      compute_jacobian(T&amp; problem){}</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> assemble(){}</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>compute_assembly{</div><div class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">      compute_assembly(T&amp; problem){}</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> assemble(){}</div><div class="line">};</div></div><!-- fragment --><p>We start the implementation of the example by writing the main file. We first instantiate the classes mentioned above</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    legendre_advection problem_(d1,d2,d3);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    compute_jacobian jac_(problem_);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    jac_.assemble();</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    compute_assembly ass_(problem_);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    ass_.assemble();</div></div><!-- fragment --><p> then we call the problem's "run" member function inside a time loop (we pass the number of iterations as an argument to the executable).</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n_it_; ++i){ <span class="comment">// Richardson iterations</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        problem_.run();</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    }</div></div><!-- fragment --><p> This is the simple API we want for our problem. We can compile this empty example to make sure that everything is set properly. We will also need to write a CMake file in order to properly set the target rules. Look at the CMakeLists.txt file for an example.</p>
<p>Now let's set up the problem.</p>
<h2>Definitions </h2>
<p>For convenience we put the discretization-related definitions inside a examples/legendre/legendre/definitions.hpp header. Here we first define some preprocessor macros </p><div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">//this MUST be included before any boost include</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#define FUSION_MAX_VECTOR_SIZE 30</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#define FUSION_MAX_MAP_SIZE FUSION_MAX_VECTOR_SIZE</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#define BOOST_MPL_LIMIT_VECTOR_SIZE FUSION_MAX_VECTOR_SIZE</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#define BACKEND_BLOCK</span></div></div><!-- fragment --><p>These extend the Boost MPL data structures and algorithms in order to hold sequences of up to 30 types. If you need to extend them further you can set this number to a larger value (for example if one of your computations have more than 30 fields). We also define the <code>BACKEND_BLOCK</code> preprocessor, which picks the block backend strategy for GridTools (see the GridTools documentation for details).</p>
<p>Next we choose the discretization for the Galerkin problem, i.e. we choose the basis functions, their order, the quadrature rule, the map from the reference finite element to the current one, and so on. </p><div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> ushort_t order_geom=1;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> ushort_t order_discr=3;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">using</span> geo_map=reference_element&lt;order_geom, Lagrange, Hexa&gt;;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">using</span> discr_map=reference_element&lt;order_discr, Legendre, Hexa&gt;;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="comment">//integrate exactly polyunomials of degree (discr_map::order*geo_map::order)</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keyword">using</span> cub=cubature&lt;4, geo_map::shape()&gt;;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keyword">using</span> discr_t = intrepid::discretization&lt;discr_map, cub&gt;;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keyword">using</span> geo_t = intrepid::geometry&lt;geo_map, cub&gt;;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">//boundary</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keyword">using</span> bd_geo_cub_t = intrepid::boundary_cub&lt;geo_map, cub::cubDegree&gt;;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keyword">using</span> bd_discr_cub_t = intrepid::boundary_cub&lt;discr_map, cub::cubDegree&gt;;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keyword">using</span> bd_geo_t = intrepid::boundary_discr&lt;bd_geo_cub_t&gt;;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keyword">using</span> bd_discr_t = intrepid::boundary_discr&lt;bd_discr_cub_t&gt;;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keyword">using</span> as=assembly&lt;geo_t&gt;;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keyword">using</span> as_bd=bd_assembly&lt;bd_geo_t&gt;;</div></div><!-- fragment --><p>In this case we chose 3rd order Legendre basis functions for the discretization (remember that these basis functions have special properties, e.g. they are not interpolatory, and they are hierarchical), and we pick a linear geometric map (Legendre basis functions of order one for mapping the reference element to the current one). The latter choice is quite standard and amounts to having an element-wise constant Jacobian. Note that we also have to define the assembly on the boundary, since we will need to evaluate boundary integrals in order to compute the fluxes. We also define short aliases for the assembly types on the element and its boundary (<code>as</code> and <code>as_bd</code> respectively).</p>
<h2>Jacobian computation </h2>
<p>We implement then the computation of the Jacobian matrix. This is described in other examples, we refer in particular to <a class="el" href="a38928.html">Mass Matrix Discretization</a> and to the documentation of <a class="el" href="a37465.html">gdl::functors::update_jac</a>. The approach followed in this example consists in creating a "repository" class, called legendre_advection in the file legendre.hpp, which contains the data structures we need in the whole example. We also start populating our stub class <code>compute_jacobian</code>. we need to deal with the following arguments in the <code>compute_jacobian</code> class, in <code>compute_jacobian.hpp</code>:</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;0, typename as_base_t::grid_type &gt;       p_grid_points;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;1, typename as::jacobian_type &gt;   p_jac;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;2, typename as::geometry_t::weights_storage_t &gt;   p_weights;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;3, typename as::storage_type &gt;    p_jac_det;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;4, typename as::jacobian_type &gt;   p_jac_inv;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;5, typename as::geometry_t::grad_storage_t&gt; p_dphi;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;6, typename as_bd::jacobian_type &gt;       p_bd_jac;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;7, typename as_bd::storage_type &gt;        p_bd_measure;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;8, typename as_bd::boundary_t::weights_storage_t&gt; p_bd_weights;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;9, typename as_bd::boundary_t::grad_storage_t&gt; p_bd_dphi;</div></div><!-- fragment --><p> Note that these type definitions are local to the <code>compute_jacobian</code> class, so that they do not clash with other type definitions. These <code>arg</code>s represent placeholders to the storages we need in the computation, namely as input:</p><ul>
<li>the grid points,</li>
<li>the cubature weights,</li>
<li>and the derivative of basis functions. We need these values both on the internal and on the boundary of the element. The outputs of the jacobian computation are</li>
<li>the jacobian matrix,</li>
<li>its determinant (or the "measure")</li>
<li>its inverse</li>
</ul>
<p>Now we can implement the compute_jacobian::assembe() member function, in the .cpp file compute_jacobian.cpp. We follow the GridTools API to generate a computation tree, and we reuse already implemented functors (<a class="el" href="a37465.html">gdl::functors::update_jac</a>, <a class="el" href="a37473.html">gdl::functors::det</a>, <a class="el" href="a37489.html">gdl::functors::inv</a>, <a class="el" href="a37541.html">gdl::functors::update_bd_jac</a>, <a class="el" href="a37557.html">gdl::functors::measure</a>)</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keyword">auto</span> compute_jacobian=gt::make_computation&lt; BACKEND &gt;(</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            m_domain, m_coords</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            , gt::make_multistage(</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                execute&lt;forward&gt;()</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                <span class="comment">//computes the jacobian in the boundary points of each element</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                , gt::make_stage&lt;functors::update_bd_jac&lt;as_bd::boundary_t, Hexa&gt; &gt;(p_grid_points(), p_bd_dphi(), p_bd_jac())</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                <span class="comment">//computes the measure of the boundaries with codimension 1 (ok, faces)</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                , gt::make_stage&lt;functors::measure&lt;as_bd::boundary_t, 1&gt; &gt;(p_bd_jac(), p_bd_measure())</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                <span class="comment">// compute the Jacobian matrix</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                , gt::make_stage&lt;functors::update_jac&lt;as::geometry_t, Hexa&gt; &gt;(p_grid_points(), p_dphi(), p_jac())</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                <span class="comment">// compute the measure (det(J))</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                , gt::make_stage&lt;functors::det&lt;geo_t&gt; &gt;(p_jac(), p_jac_det())</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                <span class="comment">// compute the jacobian inverse</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                , gt::make_stage&lt;functors::inv&lt;geo_t&gt; &gt;(p_jac(), p_jac_det(), p_jac_inv())</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                ));</div></div><!-- fragment --><p> we run the assembly and finalize the results, using the standard GridTools API</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="comment">// return</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        compute_jacobian-&gt;ready();</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        compute_jacobian-&gt;steady();</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        compute_jacobian-&gt;run();</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        compute_jacobian-&gt;finalize();</div></div><!-- fragment --><p> The only missing step is how to assign a proper storage to the placeholders we defined here. We said that the <code>legendre.hpp</code> file will contain a repository of all the storages we need in the example. So, let's deal with it. We need:</p><ul>
<li>the grid: it is contained in the <a class="el" href="a37789.html">gdl::assembly_base</a> class, so an instance of <code>assembly_base</code> will be a data member of our repository <code>m_as_base</code>).</li>
<li>the derivative of the basis functions on the quadrature points is contained in the gld::assembler class, so we'll have a <code>m_assembler</code> data member.</li>
<li>all these values on the boundary: are contained in the <a class="el" href="a37829.html">gdl::bd_assembly</a> class, so we also need an instance <code>m_bd_assembler</code></li>
</ul>
<p>For the output we have to instantiate:</p><ul>
<li>a jacobian matrix in the quadrature points. This, following the matrix data structure described in <a class="el" href="a38929.html">Matrix Vector Multiplication</a>, is represented using the first 3 indexes for the element, then one index for the quadrature point and two indices for the matrix element. It will be thus a 6 dimensional storage.</li>
<li>its inverse, is stored in an analogous data structure.</li>
<li>its determinant, will be a 4 dimensional storage, only having three indices for the elements and one for the quadrature points.</li>
<li>the data structures on the boundary are the same as the ones for the internal nodes, with an extra dimension defining which boundary we consider (for an hexahedron this extra dimension ranges from 0 to 5, and spans the faces).</li>
</ul>
<p>Once we have all the storages instantiated we can instantiate the <code>aggregator</code> which binds the <code>arg</code>s to the storages:</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        m_domain(boost::fusion::make_vector(</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                     &amp;m_rep.as_base().grid()</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                     , &amp;m_rep.assembler().jac()</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                     , &amp;m_rep.assembler().fe_backend().cub_weights()</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                     , &amp;m_rep.assembler().jac_det()</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                     , &amp;m_rep.assembler().jac_inv()</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                     , &amp;m_rep.assembler().fe_backend().grad()</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                     , &amp;m_rep.bd_assembler().bd_jac()</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                     , &amp;m_rep.bd_assembler().bd_measure()</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                     , &amp;m_rep.bd_assembler().bd_backend().bd_cub_weights()</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                     , &amp;m_rep.bd_assembler().bd_backend().grad()</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                     ))</div></div><!-- fragment --><p> Now we have implemented the Jacobian assembly, and we can already test that it works by compiling the example and running it.</p>
<h2>Matrix assembly </h2>
<p>For the matrix assembly we proceed in a similar way, by filling the <code>compute_assembly</code> class. We need the following arguments as local type definitions in compute_assembly.hpp:</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;0, typename as::geometry_t::weights_storage_t &gt;   p_weights;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;1, typename as::storage_type &gt;    p_jac_det;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;2, typename as::jacobian_type &gt;    p_jac_inv;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;3, typename as_bd::jacobian_type &gt;       p_bd_jac;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;4, typename as_bd::face_normals_type &gt;                   p_normals;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;5, typename as_bd::storage_type &gt;        p_bd_measure;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;6, typename as_bd::boundary_t::weights_storage_t&gt; p_bd_weights;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;7, typename as_bd::boundary_t::tangent_storage_t&gt; p_ref_normals;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;8, bd_matrix_type&gt; p_bd_mass_uu;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;9, bd_matrix_type&gt; p_bd_mass_uv;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;10, bd_matrix_type&gt; p_bd_mass_vu;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;11, typename as_bd::boundary_t::basis_function_storage_t&gt; p_bd_phi;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;12, matrix_type&gt; p_mass;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;13, matrix_type&gt; p_advection;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;14, physical_vec_storage_type&gt; p_beta_phys;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;15, vector_type&gt; p_beta_interp;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;16, typename discr_t::basis_function_storage_t&gt; p_phi_discr;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;17, typename discr_t::grad_storage_t&gt; p_dphi_discr;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;18, bd_scalar_type&gt; p_beta_n;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keyword">typedef</span> gt::arg&lt;19, bd_vector_type&gt; p_int_normals;</div></div><!-- fragment --><p> i.e. as input and internal data structures:</p><ul>
<li>cubature weights,</li>
<li>jacobian determinant on the internal quadrature points and on the boundary,</li>
<li>normal vectors (computed from the normals on the reference element by <a class="el" href="a37565.html">gdl::functors::compute_face_normals</a>),</li>
<li>boundary measure</li>
<li>boundary weights</li>
<li>normals on the reference finite element</li>
<li>basis functions on the boundary</li>
<li>advection term <img class="formulaInl" alt="$\beta$" src="form_37.png"/> evaluated on the quadrature points</li>
<li>advection term <img class="formulaInl" alt="$\beta$" src="form_37.png"/> written in terms of the basis functions (i.e. the expansion coefficients)</li>
<li>the value of the basis functions in the quadrature points</li>
<li>the derivative of the basis functions in the quadrature points</li>
<li>the normal component of the <img class="formulaInl" alt="$\beta$" src="form_37.png"/> advection field on the faces</li>
<li>the normal vectors integrated on the faces</li>
</ul>
<p>the output are:</p><ul>
<li>the mass matrix on the internal points</li>
<li>the mass matrix on the boundary <img class="formulaInl" alt="$ m_{uu} = \int \phi_i^+ \phi_j^+ $" src="form_38.png"/> in which both basis and test functions belong to the same element</li>
<li>the mass matrix on the boundary <img class="formulaInl" alt="$ m_{uv} = \int \phi_i^+ \phi_j^- $" src="form_39.png"/> in which the test function belongs to the neighboring element</li>
<li>the mass matrix on the boundary <img class="formulaInl" alt="$ m_{vu} = \int \phi_i^- \phi_j^+ $" src="form_40.png"/> in which the basis function belongs to the neighboring element</li>
<li>the advection matrix</li>
</ul>
<p>The computation is instantiated and ran in the assemble() member function, in compute_assembly.cpp:</p>
<p>definition of the computation</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keyword">auto</span> compute_assembly=gt::make_computation&lt; BACKEND &gt;(</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            m_domain, m_rep.coords()</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            , gt::make_multistage(</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                execute&lt;forward&gt;()</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                <span class="comment">// boundary fluxes</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                , gt::make_stage&lt;functors::bd_mass&lt;as_bd::boundary_t, as_bd::bd_cub&gt; &gt;(p_bd_measure(), p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass_uu())</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                , gt::make_stage&lt;functors::bd_mass_uv&lt;as_bd::boundary_t, as_bd::bd_cub&gt; &gt;(p_bd_measure(), p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass_uv())</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                , gt::make_stage&lt;functors::bd_mass_vu&lt;as_bd::boundary_t, as_bd::bd_cub&gt; &gt;(p_bd_measure(), p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass_vu())</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="comment">// interpolate beta</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                , gt::make_stage&lt; functors::transform_vec &gt;( p_jac_det(), p_weights(), p_phi_discr(), p_beta_phys(), p_beta_interp() )</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                <span class="comment">// compute the mass matrix</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                , gt::make_stage&lt; functors::mass &gt;(p_jac_det(), p_weights(), p_phi_discr(), p_phi_discr(), p_mass()) <span class="comment">//mass</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                <span class="comment">// compute the advection matrix</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                , gt::make_stage&lt;functors::advection&lt; geo_t, cub &gt; &gt;(p_jac_det(), p_jac_inv(), p_weights(), p_beta_interp(), p_dphi_discr(), p_phi_discr(), p_advection()) <span class="comment">//advection</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                <span class="comment">// compute the face normals: \f$ n=J*(\hat n) \f$</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                , gt::make_stage&lt;functors::compute_face_normals&lt;as_bd::boundary_t&gt; &gt;(p_bd_jac(), p_ref_normals(), p_normals())</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                <span class="comment">// interpolate the normals \f$ n=\sum_i &lt;n,\phi_i&gt;\phi_i(x) \f$</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                , gt::make_stage&lt;functors::bd_integrate&lt;as_bd::boundary_t&gt; &gt;(p_bd_phi(), p_bd_measure(), p_bd_weights(), p_normals(), p_int_normals())</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="comment">// project beta on the normal direction on the boundary \f$ \beta_n = M&lt;\beta,n&gt; \f$</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                <span class="comment">// note that beta is defined in the current space, so we take the scalar product with</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                <span class="comment">// the normals on the current configuration, i.e. \f$F\hat n\f$</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                , gt::make_stage&lt;functors::project_on_boundary&gt;(p_beta_interp(), p_int_normals(), p_bd_mass_uu(), p_beta_n())</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                ));</div></div><!-- fragment --><p> run and finalize it</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        compute_assembly-&gt;ready();</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        compute_assembly-&gt;steady();</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        compute_assembly-&gt;run();</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        compute_assembly-&gt;finalize();</div></div><!-- fragment --><p> The storage-args binding is performed when constructing the aggregator:</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        m_domain((p_weights() = m_rep.assembler().fe_backend().cub_weights())</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                 , (p_jac_det() = m_rep.assembler().jac_det())</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                 , (p_jac_inv() = m_rep.assembler().jac_inv())</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                 , (p_bd_jac() = m_rep.bd_assembler().bd_jac())</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                 , (p_normals() = m_rep.bd_assembler().normals())</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                 , (p_bd_measure() = m_rep.bd_assembler().bd_measure())</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                 , (p_bd_weights() = m_rep.bd_assembler().bd_backend().bd_cub_weights())</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                 , (p_ref_normals() = m_rep.bd_assembler().bd_backend().ref_normals())</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                 , (p_bd_mass_uu() = m_rep.bd_mass())</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                 , (p_bd_mass_uv() = m_rep.bd_mass_uv())</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                 , (p_bd_mass_vu() = m_rep.bd_mass_vu())</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                 , (p_bd_phi() = m_rep.bd_assembler().bd_backend().val())</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                 , (p_mass() = m_rep.mass())</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                 , (p_advection() = m_rep.advection())</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                 , (p_beta_phys() = m_rep.beta_phys())</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                 , (p_beta_interp() = m_rep.beta_interp())</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                 , (p_phi_discr() = m_rep.fe().val())</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                 , (p_dphi_discr() = m_rep.fe().grad())</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                 , (p_beta_n() = m_rep.bd_beta_n())</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                 , (p_int_normals() = m_rep.normals())</div></div><!-- fragment --><p> We skipped some boiler-plate storage definitions/instantiations which are in legendre_advection.hpp, because they follow the same patterns of the ones described above and in previous examples.</p>
<p>Now that we have also the assembly step set up we can compile and run the test, in order to check that everything is still working.</p>
<h2>Fluxes and Iterations </h2>
<p>So far we only did local iterations, each element gets processed independently from each other. The way the elements interact with each other in DG is via the fluxes. There are several fluxes in literature and we did not implement any of them here, leaving it as an exercise to the reader. We describe here the core of the computation, which is executed at every time iteration (as opposed to the assembly steps, which in this case can be computed once at the beginning and kept for all the iterations). This core computation is defined in the legendre.cpp file and consists in three main steps:</p><ul>
<li>a matrix-vector multiplication of the current solution times the advection matrix: <img class="formulaInl" alt="$Au^n$" src="form_41.png"/></li>
<li>the computation of the fluxes (notice that the integrals on the boundary correspond to the multiplication times the boundary mass matrices computed in the assembly steps, and notice also that when integrating basis functions belonging to 2 different elements, it is sufficient to use the <img class="formulaInl" alt="$m_{uv}$" src="form_42.png"/> or <img class="formulaInl" alt="$m_{vu}$" src="form_43.png"/>, depending on the cases, instead of <img class="formulaInl" alt="$m_{uu}$" src="form_44.png"/>): <img class="formulaInl" alt="$Au^n+F(u^n)$" src="form_45.png"/></li>
<li>the implementation of a time discretization, and multiplication times the mass matrix. For instance a stupid forward Euler scheme would give <img class="formulaInl" alt="$Mu^{n+1}=Au^n+F(u^n)+Mu^n$" src="form_46.png"/>. In case of Legendre basis functions the mass matrix <img class="formulaInl" alt="$M$" src="form_47.png"/> is diagonal, so that the linear problem above is trivial.</li>
</ul>
<p>The flux computation is perhaps the trickiest part, we refer to previous examples like <a class="el" href="a38924.html">Gather from neighbours</a> and <a class="el" href="a38921.html">DG Flux Implementation Example</a>. Remember that this is the only place in which an exchange of information between different elements happens, and it is necessary to specify the proper extent for the accessors which are accessing the i-j-k coordinates with a nonzero offset. Note also that GridTools prevents the user to write at a nonzero offset in i-j-k, although in this case could be performed in a safe manner. This constraint can be relaxed just commenting out an assertion, if needed.</p>
<h2>To be done </h2>
<ul>
<li>assign the boundary conditions. NOTE: normally we have the boundary conditions as values in quadrature points, these have to be interpolated in terms of Legendre polynomials before we can use them. Working with a modal basis means that we are solving in terms of some "expansion coefficients" which do not necessarily have a physical meaning. So each time we have to transform and counter-transform some of the fields (typically we transform to apply the boundary conditions and counter-transform to visualize the solution)</li>
<li>implement the chosen flux</li>
<li>implement the time advancing scheme </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 14 2017 12:01:27 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
